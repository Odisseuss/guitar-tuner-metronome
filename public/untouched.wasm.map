{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/memory.ts","~lib/util/memory.ts","assembly/index.ts"],"names":[],"mappings":"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","sourceRoot":"./untouched.wasm","sourcesContent":["// Alignment guarantees\r\n\r\n// @ts-ignore: decorator\r\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\r\n// @ts-ignore: decorator\r\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline export const AL_MASK: usize = AL_SIZE - 1;\r\n\r\n// Extra debugging\r\n\r\n// @ts-ignore: decorator\r\n@inline export const DEBUG = true;\r\n// @ts-ignore: decorator\r\n@inline export const TRACE = false;\r\n\r\n// Memory manager\r\n\r\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                           MM info                             │ -4\r\n// ╞>ptr═══════════════════════════════════════════════════════════╡\r\n// │                              ...                              │\r\n@unmanaged export class BLOCK {\r\n  /** Memory manager info. */\r\n  mmInfo: usize;\r\n}\r\n\r\n/** Overhead of a memory manager block. */\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\r\n\r\n/** Maximum size of a memory manager block's payload. */\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\r\n\r\n// Garbage collector\r\n\r\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                     Memory manager block                      │ -20\r\n// ╞═══════════════════════════════════════════════════════════════╡\r\n// │                            GC info                            │ -16\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                            GC info                            │ -12\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                            RT id                              │ -8\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                            RT size                            │ -4\r\n// ╞>ptr═══════════════════════════════════════════════════════════╡\r\n// │                              ...                              │\r\n@unmanaged export class OBJECT extends BLOCK {\r\n  /** Garbage collector info. */\r\n  gcInfo: u32;\r\n  /** Garbage collector info. */\r\n  gcInfo2: u32;\r\n  /** Runtime class id. */\r\n  rtId: u32;\r\n  /** Runtime object size. */\r\n  rtSize: u32;\r\n}\r\n\r\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\r\n// @ts-ignore: decorator\r\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\r\n\r\n/** Maximum size of a garbage collector object's payload. */\r\n// @ts-ignore: decorator\r\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\r\n\r\n/** Total of memory manager and garbage collector overhead. */\r\n// @ts-ignore: decorator\r\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\r\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\r\nimport { onalloc, onresize, onmove, onfree } from \"./rtrace\";\r\n\r\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\r\n// see: http://www.gii.upv.es/tlsf/\r\n\r\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\r\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\r\n\r\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\r\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\r\n// └───────────────────────────────────────────────┴───────╨───────┘\r\n// FL: first level, SL: second level, AL: alignment, SB: small block\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_BITS: u32 = 4;\r\n// @ts-ignore: decorator\r\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const FL_BITS: u32 = 31 - SB_BITS;\r\n\r\n// [00]: < 256B (SB)  [12]: < 1M\r\n// [01]: < 512B       [13]: < 2M\r\n// [02]: < 1K         [14]: < 4M\r\n// [03]: < 2K         [15]: < 8M\r\n// [04]: < 4K         [16]: < 16M\r\n// [05]: < 8K         [17]: < 32M\r\n// [06]: < 16K        [18]: < 64M\r\n// [07]: < 32K        [19]: < 128M\r\n// [08]: < 64K        [20]: < 256M\r\n// [09]: < 128K       [21]: < 512M\r\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\r\n// [11]: < 512K\r\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\r\n\r\n// Tags stored in otherwise unused alignment bits\r\n\r\n// @ts-ignore: decorator\r\n@inline const FREE: usize = 1 << 0;\r\n// @ts-ignore: decorator\r\n@inline const LEFTFREE: usize = 1 << 1;\r\n// @ts-ignore: decorator\r\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\r\n\r\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\r\n// │                          size                             │L│F│ ◄─┐ info   overhead\r\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\r\n// │                        if free: ◄ prev                        │ ◄─┤ usize\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: next ►                        │ ◄─┤\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                             ...                               │   │ >= 0\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: back ▲                        │ ◄─┘\r\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\r\n// F: FREE, L: LEFTFREE\r\n@unmanaged export class Block extends BLOCK {\r\n\r\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\r\n  prev: Block | null;\r\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\r\n  next: Block | null;\r\n\r\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\r\n}\r\n\r\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\r\n// `next` and `back` if free.\r\n\r\n// @ts-ignore: decorator\r\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\r\n// @ts-ignore: decorator\r\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\r\n\r\n/** Gets the left block of a block. Only valid if the left block is free. */\r\n// @ts-ignore: decorator\r\n@inline function GETFREELEFT(block: Block): Block {\r\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\r\n}\r\n\r\n/** Gets the right block of a block by advancing to the right by its size. */\r\n// @ts-ignore: decorator\r\n@inline function GETRIGHT(block: Block): Block {\r\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\r\n}\r\n\r\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\r\n// │        0        |           flMap                            S│ ◄────┐\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                           slMap[0] S                          │ ◄─┐  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[1]                            │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤  u32 │\r\n// │                           slMap[22]                           │ ◄─┘  │\r\n// ╞═══════════════════════════════════════════════════════════════╡    usize\r\n// │                            head[0]                            │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                              ...                              │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                           head[367]                           │ ◄────┤\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                             tail                              │ ◄────┘\r\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\r\n// S: Small blocks map\r\n@unmanaged class Root {\r\n  /** First level bitmap. */\r\n  flMap: usize;\r\n}\r\n\r\n// Root constants. Where stuff is stored inside of the root structure.\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_START: usize = sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\r\n// @ts-ignore: decorator\r\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\r\n// @ts-ignore: decorator\r\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\r\n\r\n// @ts-ignore: decorator\r\n@lazy export var ROOT: Root;\r\n\r\n/** Gets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function GETSL(root: Root, fl: usize): u32 {\r\n  return load<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Sets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\r\n  store<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    slMap,\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Gets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\r\n  return load<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Sets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\r\n  store<Block | null>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    head,\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Gets the tail block.. */\r\n// @ts-ignore: decorator\r\n@inline function GETTAIL(root: Root): Block {\r\n  return load<Block>(\r\n    changetype<usize>(root),\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Sets the tail block. */\r\n// @ts-ignore: decorator\r\n@inline function SETTAIL(root: Root, tail: Block): void {\r\n  store<Block>(\r\n    changetype<usize>(root),\r\n    tail,\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Inserts a previously used block back into the free list. */\r\nfunction insertBlock(root: Root, block: Block): void {\r\n  if (DEBUG) assert(block); // cannot be null\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n\r\n  // merge with right block if also free\r\n  if (rightInfo & FREE) {\r\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, right);\r\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\r\n      right = GETRIGHT(block);\r\n      rightInfo = right.mmInfo;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  // merge with left block if also free\r\n  if (blockInfo & LEFTFREE) {\r\n    let left = GETFREELEFT(block);\r\n    let leftInfo = left.mmInfo;\r\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\r\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, left);\r\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\r\n      block = left;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  right.mmInfo = rightInfo | LEFTFREE;\r\n  // reference to right is no longer used now, hence rightInfo is not synced\r\n\r\n  // we now know the size of the block\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\r\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\r\n\r\n  // set 'back' to itself at the end of block\r\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // perform insertion\r\n  var head = GETHEAD(root, fl, sl);\r\n  block.prev = null;\r\n  block.next = head;\r\n  if (head) head.prev = block;\r\n  SETHEAD(root, fl, sl, block);\r\n\r\n  // update first and second level maps\r\n  root.flMap |= (1 << fl);\r\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\r\n}\r\n\r\n/** Removes a free block from internal lists. */\r\nfunction removeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // link previous and next free block\r\n  var prev = block.prev;\r\n  var next = block.next;\r\n  if (prev) prev.next = next;\r\n  if (next) next.prev = prev;\r\n\r\n  // update head if we are removing it\r\n  if (block == GETHEAD(root, fl, sl)) {\r\n    SETHEAD(root, fl, sl, next);\r\n\r\n    // clear second level map if head is empty now\r\n    if (!next) {\r\n      let slMap = GETSL(root, fl);\r\n      SETSL(root, fl, slMap &= ~(1 << sl));\r\n\r\n      // clear first level map if second level is empty now\r\n      if (!slMap) root.flMap &= ~(1 << fl);\r\n    }\r\n  }\r\n  // note: does not alter left/back because it is likely that splitting\r\n  // is performed afterwards, invalidating those changes. so, the caller\r\n  // must perform those updates.\r\n}\r\n\r\n/** Searches for a free block of at least the specified size. */\r\nfunction searchBlock(root: Root, size: usize): Block | null {\r\n  // size was already asserted by caller\r\n\r\n  // mapping_search\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    const invRound = inv - SL_BITS;\r\n    let requestSize = size < halfMaxSize\r\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\r\n      : size;\r\n    fl = inv - clz<usize>(requestSize);\r\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // search second level\r\n  var slMap = GETSL(root, fl) & (~0 << sl);\r\n  var head: Block | null = null;\r\n  if (!slMap) {\r\n    // search next larger first level\r\n    let flMap = root.flMap & (~0 << (fl + 1));\r\n    if (!flMap) {\r\n      head = null;\r\n    } else {\r\n      fl = ctz<usize>(flMap);\r\n      slMap = GETSL(root, fl);\r\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\r\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n    }\r\n  } else {\r\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n  }\r\n  return head;\r\n}\r\n\r\n/** Prepares the specified block before (re-)use, possibly splitting it. */\r\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\r\n  // size was already asserted by caller\r\n\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\r\n\r\n  // split if the block can hold another MINSIZE block incl. overhead\r\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\r\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\r\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\r\n\r\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\r\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\r\n    insertBlock(root, spare); // also sets 'back'\r\n\r\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\r\n  } else {\r\n    block.mmInfo = blockInfo & ~FREE;\r\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\r\n  }\r\n}\r\n\r\n/** Adds more memory to the pool. */\r\nfunction addMemory(root: Root, start: usize, end: usize): bool {\r\n  if (DEBUG) assert(start <= end); // must be valid\r\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\r\n  end &= ~AL_MASK;\r\n\r\n  var tail = GETTAIL(root);\r\n  var tailInfo: usize = 0;\r\n  if (tail) { // more memory\r\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\r\n\r\n    // merge with current tail if adjacent\r\n    const offsetToTail = AL_SIZE;\r\n    if (start - offsetToTail == changetype<usize>(tail)) {\r\n      start -= offsetToTail;\r\n      tailInfo = tail.mmInfo;\r\n    } else {\r\n      // We don't do this, but a user might `memory.grow` manually\r\n      // leading to non-adjacent pages managed by TLSF.\r\n    }\r\n\r\n  } else if (DEBUG) { // first memory\r\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\r\n  }\r\n\r\n  // check if size is large enough for a free block and the tail block\r\n  var size = end - start;\r\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\r\n    return false;\r\n  }\r\n\r\n  // left size is total minus its own and the zero-length tail's header\r\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\r\n  var left = changetype<Block>(start);\r\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\r\n  left.prev = null;\r\n  left.next = null;\r\n\r\n  // tail is a zero-length used block\r\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\r\n  tail.mmInfo = 0 | LEFTFREE;\r\n  SETTAIL(root, tail);\r\n\r\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\r\n\r\n  return true;\r\n}\r\n\r\n/** Grows memory to fit at least another block of the specified size. */\r\nfunction growMemory(root: Root, size: usize): void {\r\n  if (ASC_LOW_MEMORY_LIMIT) {\r\n    unreachable();\r\n    return;\r\n  }\r\n  // Here, both rounding performed in searchBlock ...\r\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\r\n  if (size < halfMaxSize) { // don't round last fl\r\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\r\n    size += (1 << (invRound - clz<usize>(size))) - 1;\r\n  }\r\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\r\n  // to merge with the tail block, that's one time, otherwise it's two times.\r\n  var pagesBefore = memory.size();\r\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\r\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\r\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n  if (memory.grow(pagesWanted) < 0) {\r\n    if (memory.grow(pagesNeeded) < 0) unreachable();\r\n  }\r\n  var pagesAfter = memory.size();\r\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\r\n}\r\n\r\n/** Computes the size (excl. header) of a block. */\r\nfunction computeSize(size: usize): usize {\r\n  // Size must be large enough and aligned minus preceeding overhead\r\n  return size <= BLOCK_MINSIZE\r\n    ? BLOCK_MINSIZE\r\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\r\n}\r\n\r\n/** Prepares and checks an allocation size. */\r\nfunction prepareSize(size: usize): usize {\r\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\r\n  return computeSize(size);\r\n}\r\n\r\n/** Initializes the root structure. */\r\nfunction initialize(): void {\r\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\r\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\r\n  var root = changetype<Root>(rootOffset);\r\n  root.flMap = 0;\r\n  SETTAIL(root, changetype<Block>(0));\r\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\r\n    SETSL(root, fl, 0);\r\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\r\n      SETHEAD(root, fl, sl, null);\r\n    }\r\n  }\r\n  var memStart = rootOffset + ROOT_SIZE;\r\n  if (ASC_LOW_MEMORY_LIMIT) {\r\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\r\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\r\n    else unreachable(); // low memory limit already exceeded\r\n  } else {\r\n    addMemory(root, memStart, memory.size() << 16);\r\n  }\r\n  ROOT = root;\r\n}\r\n\r\n/** Allocates a block of the specified size. */\r\nexport function allocateBlock(root: Root, size: usize): Block {\r\n  var payloadSize = prepareSize(size);\r\n  var block = searchBlock(root, payloadSize);\r\n  if (!block) {\r\n    growMemory(root, payloadSize);\r\n    block = changetype<Block>(searchBlock(root, payloadSize));\r\n    if (DEBUG) assert(block); // must be found now\r\n  }\r\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\r\n  removeBlock(root, <Block>block);\r\n  prepareBlock(root, <Block>block, payloadSize);\r\n  if (isDefined(ASC_RTRACE)) onalloc(block);\r\n  return <Block>block;\r\n}\r\n\r\n/** Reallocates a block to the specified size. */\r\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\r\n  var payloadSize = prepareSize(size);\r\n  var blockInfo = block.mmInfo;\r\n  var blockSize = blockInfo & ~TAGS_MASK;\r\n\r\n  // possibly split and update runtime size if it still fits\r\n  if (payloadSize <= blockSize) {\r\n    prepareBlock(root, block, payloadSize);\r\n    if (isDefined(ASC_RTRACE)) {\r\n      if (payloadSize != blockSize) onresize(block, blockSize);\r\n    }\r\n    return block;\r\n  }\r\n\r\n  // merge with right free block if merger is large enough\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n  if (rightInfo & FREE) {\r\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (mergeSize >= payloadSize) {\r\n      removeBlock(root, right);\r\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\r\n      // is immediately split though. does this trigger any assertions / issues?\r\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\r\n      prepareBlock(root, block, payloadSize);\r\n      if (isDefined(ASC_RTRACE)) onresize(block, blockSize);\r\n      return block;\r\n    }\r\n  }\r\n\r\n  // otherwise move the block\r\n  return moveBlock(root, block, size);\r\n}\r\n\r\n/** Moves a block to a new one of the specified size. */\r\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\r\n  var newBlock = allocateBlock(root, newSize);\r\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\r\n  if (changetype<usize>(block) >= __heap_base) {\r\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\r\n    freeBlock(root, block);\r\n  }\r\n  return newBlock;\r\n}\r\n\r\n/** Frees a block. */\r\nexport function freeBlock(root: Root, block: Block): void {\r\n  block.mmInfo = block.mmInfo | FREE;\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n  insertBlock(root, block);\r\n}\r\n\r\n/** Checks that a used block is valid to be freed or reallocated. */\r\nfunction checkUsedBlock(ptr: usize): Block {\r\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\r\n  assert(\r\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\r\n    !(block.mmInfo & FREE)           // must be used\r\n  );\r\n  return block;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __alloc(size: usize): usize {\r\n  if (!ROOT) initialize();\r\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __realloc(ptr: usize, size: usize): usize {\r\n  if (!ROOT) initialize();\r\n  return (ptr < __heap_base\r\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\r\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\r\n  ) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __free(ptr: usize): void {\r\n  if (ptr < __heap_base) return;\r\n  if (!ROOT) initialize();\r\n  freeBlock(ROOT, checkUsedBlock(ptr));\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __reset(): void {\r\n  throw new Error(\"not implemented\");\r\n}\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\r\n// │                             count                             │\r\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\r\n// │                      Typeinfo#flags [id=0]                    │ id < count\r\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\r\n// │                      Typeinfo#base  [id=0]                    │\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                              ...                              │\r\n\r\n/** Runtime type information data structure. */\r\n@unmanaged\r\nexport class Typeinfo {\r\n  /** Flags describing the shape of this class type. */\r\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\r\n  /** Base class id or `0` if none. */\r\n  base: u32 = 0;\r\n}\r\n\r\n/** Runtime type information flags. */\r\nexport const enum TypeinfoFlags {\r\n  /** No specific flags. */\r\n  NONE = 0,\r\n  /** Type is an `ArrayBufferView`. */\r\n  ARRAYBUFFERVIEW = 1 << 0,\r\n  /** Type is an `Array`. */\r\n  ARRAY = 1 << 1,\r\n  /** Type is a `StaticArray`. */\r\n  STATICARRAY = 1 << 2,\r\n  /** Type is a `Set`. */\r\n  SET = 1 << 3,\r\n  /** Type is a `Map`. */\r\n  MAP = 1 << 4,\r\n  /** Type is inherently acyclic. */\r\n  ACYCLIC = 1 << 5,\r\n  /** Value alignment of 1 byte. */\r\n  VALUE_ALIGN_0 = 1 << 6,\r\n  /** Value alignment of 2 bytes. */\r\n  VALUE_ALIGN_1 = 1 << 7,\r\n  /** Value alignment of 4 bytes. */\r\n  VALUE_ALIGN_2 = 1 << 8,\r\n  /** Value alignment of 8 bytes. */\r\n  VALUE_ALIGN_3 = 1 << 9,\r\n  /** Value alignment of 16 bytes. */\r\n  VALUE_ALIGN_4 = 1 << 10,\r\n  /** Value is a signed type. */\r\n  VALUE_SIGNED = 1 << 11,\r\n  /** Value is a float type. */\r\n  VALUE_FLOAT = 1 << 12,\r\n  /** Value type is nullable. */\r\n  VALUE_NULLABLE = 1 << 13,\r\n  /** Value type is managed. */\r\n  VALUE_MANAGED = 1 << 14,\r\n  /** Key alignment of 1 byte. */\r\n  KEY_ALIGN_0 = 1 << 15,\r\n  /** Key alignment of 2 bytes. */\r\n  KEY_ALIGN_1 = 1 << 16,\r\n  /** Key alignment of 4 bytes. */\r\n  KEY_ALIGN_2 = 1 << 17,\r\n  /** Key alignment of 8 bytes. */\r\n  KEY_ALIGN_3 = 1 << 18,\r\n  /** Key alignment of 16 bytes. */\r\n  KEY_ALIGN_4 = 1 << 19,\r\n  /** Key is a signed type. */\r\n  KEY_SIGNED = 1 << 20,\r\n  /** Key is a float type. */\r\n  KEY_FLOAT = 1 << 21,\r\n  /** Key type is nullable. */\r\n  KEY_NULLABLE = 1 << 22,\r\n  /** Key type is managed. */\r\n  KEY_MANAGED = 1 << 23\r\n}\r\n","import { BLOCK_OVERHEAD, DEBUG, OBJECT, OBJECT_MAXSIZE, OBJECT_OVERHEAD, TOTAL_OVERHEAD } from \"rt/common\";\r\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\r\nimport { TypeinfoFlags } from \"shared/typeinfo\";\r\nimport { onincrement, ondecrement } from \"./rtrace\";\r\n\r\n// === A Pure Reference Counting Garbage Collector ===\r\n// see: https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\r\n\r\n// ╒══════════════════════ GC Info structure ══════════════════════╕\r\n// │  3                   2                   1                    │\r\n// │1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│\r\n// ├─┼─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │B│color│                     refCount                          │\r\n// └─┴─────┴───────────────────────────────────────────────────────┘\r\n// B: buffered\r\n\r\n// @ts-ignore: decorator\r\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BITS = 3;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\r\n\r\n// ╒════════╤═══════════════════ Colors ═══════════════════════════╕\r\n// │ Color  │ Meaning                                              │\r\n// ├────────┼──────────────────────────────────────────────────────┤\r\n// │ BLACK  │ In use or free                                       │\r\n// │ GRAY   │ Possible member of cycle                             │\r\n// │ WHITE  │ Member of garbage cycle                              │\r\n// │ PURPLE │ Possible root of cycle                               │\r\n// │ RED    │ Candidate cycle undergoing Σ-computation *concurrent │\r\n// │ ORANGE │ Candidate cycle awaiting epoch boundary  *concurrent │\r\n// └────────┴──────────────────────────────────────────────────────┘\r\n// Acyclic detection has been decoupled, hence no GREEN.\r\n\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n// @inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n// @inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\r\n\r\n// @ts-ignore: decorator\r\n@inline const VISIT_DECREMENT = 1; // guard 0\r\n// @ts-ignore: decorator\r\n@inline const VISIT_MARKGRAY = 2;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCAN = 3;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCANBLACK = 4;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_COLLECTWHITE = 5;\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe @lazy\r\nfunction __visit(ref: usize, cookie: i32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\r\n  if (ref < __heap_base) return;\r\n  if (isDefined(__GC_ALL_ACYCLIC)) {\r\n    if (DEBUG) assert(cookie == VISIT_DECREMENT);\r\n    decrement(changetype<OBJECT>(ref - TOTAL_OVERHEAD));\r\n  } else {\r\n    let s = changetype<OBJECT>(ref - TOTAL_OVERHEAD);\r\n    switch (cookie) {\r\n      case VISIT_DECREMENT: {\r\n        decrement(s);\r\n        break;\r\n      }\r\n      case VISIT_MARKGRAY: {\r\n        if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\r\n        s.gcInfo = s.gcInfo - 1;\r\n        markGray(s);\r\n        break;\r\n      }\r\n      case VISIT_SCAN: {\r\n        scan(s);\r\n        break;\r\n      }\r\n      case VISIT_SCANBLACK: {\r\n        let info = s.gcInfo;\r\n        assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n        s.gcInfo = info + 1;\r\n        if ((info & COLOR_MASK) != COLOR_BLACK) {\r\n          scanBlack(s);\r\n        }\r\n        break;\r\n      }\r\n      case VISIT_COLLECTWHITE: {\r\n        collectWhite(s);\r\n        break;\r\n      }\r\n      default: if (DEBUG) assert(false);\r\n    }\r\n  }\r\n}\r\n\r\n/** Increments the reference count of the specified block by one.*/\r\nfunction increment(s: OBJECT): void {\r\n  var info = s.gcInfo;\r\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n  s.gcInfo = info + 1;\r\n  if (isDefined(ASC_RTRACE)) onincrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n}\r\n\r\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\r\n// @ts-ignore: decorator\r\n@lazy\r\nfunction decrement(s: OBJECT): void {\r\n  var info = s.gcInfo;\r\n  var rc = info & REFCOUNT_MASK;\r\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n  if (rc == 1) {\r\n    __visit_members(changetype<usize>(s) + TOTAL_OVERHEAD, VISIT_DECREMENT);\r\n    if (isDefined(__GC_ALL_ACYCLIC)) {\r\n      if (DEBUG) assert(!(info & BUFFERED_MASK));\r\n      finalize(s);\r\n    } else {\r\n      if (!(info & BUFFERED_MASK)) {\r\n        finalize(s);\r\n      } else {\r\n        s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\r\n      }\r\n    }\r\n  } else {\r\n    if (DEBUG) assert(rc > 0);\r\n    if (isDefined(__GC_ALL_ACYCLIC)) {\r\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\r\n    } else {\r\n      if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\r\n        s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\r\n        if (!(info & BUFFERED_MASK)) {\r\n          appendRoot(s);\r\n        }\r\n      } else {\r\n        s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** Finalizes the specified block, giving it back to the memory manager. */\r\nfunction finalize(s: OBJECT): void {\r\n  if (isDefined(__finalize)) {\r\n    __finalize(changetype<usize>(s) + TOTAL_OVERHEAD);\r\n  }\r\n  freeBlock(ROOT, changetype<Block>(s));\r\n}\r\n\r\n/** Buffer of possible roots. */\r\n// @ts-ignore: decorator\r\n@lazy var ROOTS: usize;\r\n/** Current absolute offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var CUR: usize = 0;\r\n/** Current absolute end offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var END: usize = 0;\r\n\r\n/** Appends a block to possible roots. */\r\nfunction appendRoot(s: OBJECT): void {\r\n  var cur = CUR;\r\n  if (cur >= END) {\r\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\r\n    cur = CUR;\r\n  }\r\n  store<OBJECT>(cur, s);\r\n  CUR = cur + sizeof<usize>();\r\n}\r\n\r\n/** Grows the roots buffer if it ran full. */\r\nfunction growRoots(): void {\r\n  var oldRoots = ROOTS;\r\n  var oldSize = CUR - oldRoots;\r\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\r\n  var newRoots = __alloc(newSize);\r\n  memory.copy(newRoots, oldRoots, oldSize);\r\n  if (oldRoots) __free(oldRoots);\r\n  ROOTS = newRoots;\r\n  CUR = newRoots + oldSize;\r\n  END = newRoots + newSize;\r\n}\r\n\r\n/** Collects cyclic garbage. */\r\n// @ts-ignore: decorator\r\n@global @unsafe @lazy\r\nexport function __collect(): void {\r\n  if (isDefined(__GC_ALL_ACYCLIC)) return;\r\n\r\n  // markRoots\r\n  var roots = ROOTS;\r\n  var cur = roots;\r\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\r\n    let s = load<OBJECT>(pos);\r\n    let info = s.gcInfo;\r\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\r\n      markGray(s);\r\n      store<OBJECT>(cur, s);\r\n      cur += sizeof<usize>();\r\n    } else {\r\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\r\n        finalize(s);\r\n      } else {\r\n        s.gcInfo = info & ~BUFFERED_MASK;\r\n      }\r\n    }\r\n  }\r\n  CUR = cur;\r\n\r\n  // scanRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    scan(load<OBJECT>(pos));\r\n  }\r\n\r\n  // collectRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    let s = load<OBJECT>(pos);\r\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\r\n    collectWhite(s);\r\n  }\r\n  CUR = roots;\r\n}\r\n\r\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\r\nfunction markGray(s: OBJECT): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\r\n    __visit_members(changetype<usize>(s) + TOTAL_OVERHEAD, VISIT_MARKGRAY);\r\n  }\r\n}\r\n\r\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\r\nfunction scan(s: OBJECT): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\r\n    if ((info & REFCOUNT_MASK) > 0) {\r\n      scanBlack(s);\r\n    } else {\r\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\r\n      __visit_members(changetype<usize>(s) + TOTAL_OVERHEAD, VISIT_SCAN);\r\n    }\r\n  }\r\n}\r\n\r\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\r\nfunction scanBlack(s: OBJECT): void {\r\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\r\n  __visit_members(changetype<usize>(s) + TOTAL_OVERHEAD, VISIT_SCANBLACK);\r\n}\r\n\r\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\r\nfunction collectWhite(s: OBJECT): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\r\n    __visit_members(changetype<usize>(s) + TOTAL_OVERHEAD, VISIT_COLLECTWHITE);\r\n    finalize(s);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __new(size: usize, id: u32): usize {\r\n  if (size > OBJECT_MAXSIZE) throw new Error(\"allocation too large\");\r\n  var ptr = __alloc(OBJECT_OVERHEAD + size);\r\n  var object = changetype<OBJECT>(ptr - BLOCK_OVERHEAD);\r\n  object.gcInfo = 0; // RC=0\r\n  object.gcInfo2 = 0;\r\n  object.rtId = id;\r\n  object.rtSize = <u32>size;\r\n  return ptr + OBJECT_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __renew(oldPtr: usize, size: usize): usize {\r\n  if (size > OBJECT_MAXSIZE) throw new Error(\"allocation too large\");\r\n  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size);\r\n  changetype<OBJECT>(newPtr - BLOCK_OVERHEAD).rtSize = <u32>size;\r\n  return newPtr + OBJECT_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __retain(ptr: usize): usize {\r\n  if (ptr > __heap_base) increment(changetype<OBJECT>(ptr - TOTAL_OVERHEAD));\r\n  return ptr;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __release(ptr: usize): void {\r\n  if (ptr > __heap_base) decrement(changetype<OBJECT>(ptr - TOTAL_OVERHEAD));\r\n}\r\n","import { memcmp, memmove, memset } from \"./util/memory\";\r\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\r\n\r\n/** Memory manager interface. */\r\nexport namespace memory {\r\n\r\n  /** Gets the size of the memory in pages. */\r\n  // @ts-ignore: decorator\r\n  @builtin\r\n  export declare function size(): i32;\r\n\r\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export declare function grow(pages: i32): i32;\r\n\r\n  /** Fills a section in memory with the specified byte value. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function fill(dst: usize, c: u8, n: usize): void {\r\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Copies a section of memory to another. Has move semantics. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function copy(dst: usize, src: usize, n: usize): void {\r\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Initializes a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Drops a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function drop(segmentIndex: u32): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Repeats a section of memory at a specific address. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\r\n    var index: usize = 0;\r\n    var total = srcLength * count;\r\n    while (index < total) {\r\n      memory.copy(dst + index, src, srcLength);\r\n      index += srcLength;\r\n    }\r\n  }\r\n\r\n  /** Compares a section of memory to another. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\r\n    return memcmp(vl, vr, n);\r\n  }\r\n\r\n  /** Gets a pointer to a static chunk of memory of the given size. */\r\n  // @ts-ignore: decorator\r\n  @builtin\r\n  export declare function data<T>(size: T, align?: i32): usize;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@builtin\r\nexport declare const __heap_base: usize;\r\n\r\n/** Heap memory interface. */\r\nexport namespace heap {\r\n\r\n  /** Allocates a chunk of memory of at least the specified size. */\r\n  // @ts-ignore: decorator\r\n  @unsafe export function alloc(size: usize): usize {\r\n    return __alloc(size);\r\n  }\r\n\r\n  /** Reallocates a chunk of memory to have at least the specified size. */\r\n  // @ts-ignore: decorator\r\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\r\n    return __realloc(ptr, size);\r\n  }\r\n\r\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub/none runtime. */\r\n  // @ts-ignore: decorator\r\n  @unsafe export function free(ptr: usize): void {\r\n    __free(ptr);\r\n  }\r\n\r\n  /** Dangerously resets the entire heap. Specific to the stub/none runtime. */\r\n  // @ts-ignore: decorator\r\n  @unsafe export function reset(): void {\r\n    __reset();\r\n  }\r\n}\r\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (<u32>dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (src - dest - n <= -(n << 1)) {\r\n      memcpy(dest, src, n);\r\n      return;\r\n    }\r\n  }\r\n  if (dest < src) {\r\n    if (ASC_SHRINK_LEVEL < 2) {\r\n      if ((src & 7) == (dest & 7)) {\r\n        while (dest & 7) {\r\n          if (!n) return;\r\n          --n;\r\n          store<u8>(dest++, load<u8>(src++));\r\n        }\r\n        while (n >= 8) {\r\n          store<u64>(dest, load<u64>(src));\r\n          n    -= 8;\r\n          dest += 8;\r\n          src  += 8;\r\n        }\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if (ASC_SHRINK_LEVEL < 2) {\r\n      if ((src & 7) == (dest & 7)) {\r\n        while ((dest + n) & 7) {\r\n          if (!n) return;\r\n          store<u8>(dest + --n, load<u8>(src + n));\r\n        }\r\n        while (n >= 8) {\r\n          n -= 8;\r\n          store<u64>(dest + n, load<u64>(src + n));\r\n        }\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    while (n) {\r\n      store<u8>(dest++, c);\r\n      --n;\r\n    }\r\n  } else {\r\n    // fill head and tail with minimal branching\r\n    if (!n) return;\r\n    let dend = dest + n - 4;\r\n    store<u8>(dest, c);\r\n    store<u8>(dend, c, 3);\r\n    if (n <= 2) return;\r\n    store<u8>(dest, c, 1);\r\n    store<u8>(dest, c, 2);\r\n    store<u8>(dend, c, 2);\r\n    store<u8>(dend, c, 1);\r\n    if (n <= 6) return;\r\n    store<u8>(dest, c, 3);\r\n    store<u8>(dend, c);\r\n    if (n <= 8) return;\r\n\r\n    // advance pointer to align it at 4-byte boundary\r\n    let k: usize = -dest & 3;\r\n    dest += k;\r\n    n -= k;\r\n    n &= -4;\r\n\r\n    let c32: u32 = <u32>-1 / 255 * c;\r\n\r\n    // fill head/tail up to 28 bytes each in preparation\r\n    dend = dest + n - 28;\r\n    store<u32>(dest, c32);\r\n    store<u32>(dend, c32, 24);\r\n    if (n <= 8) return;\r\n    store<u32>(dest, c32, 4);\r\n    store<u32>(dest, c32, 8);\r\n    store<u32>(dend, c32, 16);\r\n    store<u32>(dend, c32, 20);\r\n    if (n <= 24) return;\r\n    store<u32>(dest, c32, 12);\r\n    store<u32>(dest, c32, 16);\r\n    store<u32>(dest, c32, 20);\r\n    store<u32>(dest, c32, 24);\r\n    store<u32>(dend, c32);\r\n    store<u32>(dend, c32, 4);\r\n    store<u32>(dend, c32, 8);\r\n    store<u32>(dend, c32, 12);\r\n\r\n    // align to a multiple of 8\r\n    k = 24 + (dest & 4);\r\n    dest += k;\r\n    n -= k;\r\n\r\n    // copy 32 bytes each\r\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n    while (n >= 32) {\r\n      store<u64>(dest, c64);\r\n      store<u64>(dest, c64, 8);\r\n      store<u64>(dest, c64, 16);\r\n      store<u64>(dest, c64, 24);\r\n      n -= 32;\r\n      dest += 32;\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\r\n  if (vl == vr) return 0;\r\n  if (ASC_SHRINK_LEVEL < 2) {\r\n    if ((vl & 7) == (vr & 7)) {\r\n      while (vl & 7) {\r\n        if (!n) return 0;\r\n        let a = <i32>load<u8>(vl);\r\n        let b = <i32>load<u8>(vr);\r\n        if (a != b) return a - b;\r\n        n--; vl++; vr++;\r\n      }\r\n      while (n >= 8) {\r\n        if (load<u64>(vl) != load<u64>(vr)) break;\r\n        vl += 8;\r\n        vr += 8;\r\n        n  -= 8;\r\n      }\r\n    }\r\n  }\r\n  while (n--) {\r\n    let a = <i32>load<u8>(vl);\r\n    let b = <i32>load<u8>(vr);\r\n    if (a != b) return a - b;\r\n    vl++; vr++;\r\n  }\r\n  return 0;\r\n}\r\n","// The entry file of your WebAssembly module.\n\nexport function add(a: i32, b: i32): i32 {\n  return a + b;\n}\n"]}