{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/automation-events/build/es5/bundle.js","../../../src/globals.ts","../../../../src/helpers/is-constructible.ts","../../../../src/helpers/split-import-statements.ts","../../../../src/factories/add-audio-worklet-module.ts","../../../../src/helpers/get-value-for-key.ts","../../../../src/helpers/pick-element-from-set.ts","../../../../src/helpers/delete-passive-input-connection-to-audio-node.ts","../../../../src/helpers/get-event-listeners-of-audio-node.ts","../../../../src/helpers/set-internal-state-to-active.ts","../../../../src/guards/audio-worklet-node.ts","../../../../src/helpers/set-internal-state-to-passive.ts","../../../../src/helpers/set-internal-state-to-passive-when-necessary.ts","../../../../src/factories/analyser-node-constructor.ts","../../../../src/helpers/is-owned-by-context.ts","../../../../src/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.ts","../../../../src/factories/index-size-error.ts","../../../../src/helpers/wrap-audio-buffer-get-channel-data-method.ts","../../../../src/factories/audio-buffer-constructor.ts","../../../src/constants.ts","../../../../src/helpers/is-active-audio-node.ts","../../../../src/factories/audio-buffer-source-node-constructor.ts","../../../../src/helpers/get-audio-node-connections.ts","../../../../src/helpers/get-audio-param-connections.ts","../../../../src/helpers/deactivate-active-audio-node-input-connections.ts","../../../../src/guards/audio-buffer-source-node.ts","../../../../src/guards/biquad-filter-node.ts","../../../../src/guards/constant-source-node.ts","../../../../src/guards/gain-node.ts","../../../../src/guards/oscillator-node.ts","../../../../src/guards/stereo-panner-node.ts","../../../../src/helpers/deactivate-audio-graph.ts","../../../../src/helpers/is-valid-latency-hint.ts","../../../../src/guards/audio-node.ts","../../../../src/guards/audio-node-output-connection.ts","../../../../src/helpers/insert-element-in-set.ts","../../../../src/helpers/add-active-input-connection-to-audio-param.ts","../../../../src/helpers/add-passive-input-connection-to-audio-param.ts","../../../../src/guards/native-audio-node-faker.ts","../../../../src/helpers/connect-native-audio-node-to-native-audio-node.ts","../../../../src/helpers/delete-active-input-connection.ts","../../../../src/helpers/delete-event-listeners-of-audio-node.ts","../../../../src/helpers/delete-passive-input-connection-to-audio-param.ts","../../../../src/helpers/disconnect-native-audio-node-from-native-audio-node.ts","../../../../src/helpers/get-native-audio-node.ts","../../../../src/helpers/get-native-audio-param.ts","../../../../src/helpers/is-part-of-a-cycle.ts","../../../../src/helpers/is-passive-audio-node.ts","../../../../src/helpers/test-audio-node-disconnect-method-support.ts","../../../../src/helpers/visit-each-audio-node-once.ts","../../../../src/guards/native-audio-node.ts","../../../../src/factories/audio-node-constructor.ts","../../../../src/helpers/delete-active-input-connection-to-audio-param.ts","../../../src/read-only-map.ts","../../../../src/factories/audio-worklet-node-constructor.ts","../../../../src/helpers/copy-from-channel.ts","../../../../src/helpers/copy-to-channel.ts","../../../../src/helpers/create-nested-arrays.ts","../../../../src/helpers/get-audio-worklet-processor.ts","../../../../src/factories/audio-worklet-node-renderer-factory.ts","../../../../src/factories/biquad-filter-node-constructor.ts","../../../../src/factories/channel-merger-node-constructor.ts","../../../../src/factories/channel-splitter-node-constructor.ts","../../../../src/factories/constant-source-node-constructor.ts","../../../../src/factories/convolver-node-constructor.ts","../../../../src/factories/delay-node-constructor.ts","../../../../src/factories/disconnect-multiple-outputs.ts","../../../../src/factories/dynamics-compressor-node-constructor.ts","../../../../src/factories/gain-node-constructor.ts","../../../../src/factories/invalid-state-error.ts","../../../../src/factories/invalid-access-error.ts","../../../../src/factories/iir-filter-node-constructor.ts","../../../../src/helpers/filter-buffer.ts","../../../../src/factories/iir-filter-node-renderer-factory.ts","../../../../src/factories/media-stream-audio-destination-node-constructor.ts","../../../../src/helpers/test-promise-support.ts","../../../../src/factories/minimal-offline-audio-context-constructor.ts","../../../../src/helpers/assign-native-audio-node-option.ts","../../../../src/helpers/assign-native-audio-node-options.ts","../../../../src/helpers/test-analyser-node-get-float-time-domain-data-method-support.ts","../../../../src/helpers/assign-native-audio-node-audio-param-value.ts","../../../../src/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.ts","../../../../src/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.ts","../../../../src/helpers/compute-buffer-size.ts","../../../../src/helpers/clone-audio-worklet-node-options.ts","../../../../src/helpers/create-audio-worklet-processor-promise.ts","../../../../src/factories/native-biquad-filter-node.ts","../../../../src/factories/native-channel-splitter-node.ts","../../../../src/helpers/wrap-channel-splitter-node.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../../../src/helpers/intercept-connections.ts","../../../../src/factories/native-delay-node.ts","../../../../src/factories/native-gain-node.ts","../../../../src/factories/native-iir-filter-node-faker-factory.ts","../../../../src/factories/add-active-input-connection-to-audio-node.ts","../../../../src/factories/delete-active-input-connection-to-audio-node.ts","../../../../src/factories/cache-test-result.ts","../../../../src/factories/native-analyser-node-factory.ts","../../../../src/factories/get-audio-node-renderer.ts","../../../../src/factories/analyser-node-renderer-factory.ts","../../../../src/factories/get-native-context.ts","../../../../src/factories/is-native-offline-audio-context.ts","../../../../src/factories/event-target-constructor.ts","../../../../src/factories/is-native-audio-context.ts","../../../../src/factories/add-audio-node-connections.ts","../../../../src/factories/convert-number-to-unsigned-long.ts","../../../../src/factories/test-audio-buffer-constructor-support.ts","../../../../src/factories/add-silent-connection.ts","../../../../src/factories/render-inputs-of-audio-param.ts","../../../../src/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.ts","../../../../src/factories/add-audio-param-connections.ts","../../../../src/factories/wrap-channel-merger-node.ts","../../../../src/factories/native-dynamics-compressor-node-factory.ts","../../../../src/factories/native-iir-filter-node-factory.ts","../../../../src/factories/connected-native-audio-buffer-source-node-factory.ts","../../../../src/factories/native-panner-node-factory.ts","../../../../src/factories/fetch-source.ts","../../../../src/factories/base-audio-context-constructor.ts","../../../../src/factories/get-unrendered-audio-worklet-nodes.ts","../../../../src/factories/add-unrendered-audio-worklet-node.ts","../../../../src/factories/is-any-audio-node.ts","../../../../src/factories/is-any-audio-param.ts","../../../../src/factories/native-script-processor-node.ts","../../../../src/factories/not-supported-error.ts","../../../../src/factories/offline-audio-context-constructor.ts","../../../../src/factories/oscillator-node-constructor.ts","../../../../src/factories/panner-node-constructor.ts","../../../../src/factories/periodic-wave-constructor.ts","../../../../src/factories/stereo-panner-node-constructor.ts","../../../../src/factories/unknown-error.ts","../../../../src/factories/wave-shaper-node-constructor.ts","../../../../src/helpers/is-dc-curve.ts","../../../../src/helpers/overwrite-accessors.ts","../../../../src/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.ts","../../../../src/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.ts","../../../../src/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.ts","../../../../src/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts","../../../../src/helpers/wrap-event-listener.ts","../../../src/module.ts","../../../../src/factories/add-passive-input-connection-to-audio-node.ts","../../../../src/factories/get-audio-node-tail-time.ts","../../../../src/factories/window.ts","../../../../src/helpers/wrap-analyser-node-get-float-time-domain-data-method.ts","../../../../src/factories/render-inputs-of-audio-node.ts","../../../../src/factories/native-offline-audio-context-constructor.ts","../../../../src/factories/native-audio-context-constructor.ts","../../../../src/factories/is-native-audio-node.ts","../../../../src/factories/is-native-audio-param.ts","../../../../src/helpers/wrap-audio-node-disconnect-method.ts","../../../../src/factories/add-connection-to-audio-node.ts","../../../../src/factories/increment-cycle-counter-factory.ts","../../../../src/factories/decrement-cycle-counter.ts","../../../../src/factories/detect-cycles.ts","../../../../src/guards/delay-node.ts","../../../../src/factories/native-audio-buffer-constructor.ts","../../../../src/factories/wrap-audio-buffer-copy-channel-methods.ts","../../../../src/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.ts","../../../../src/factories/connect-audio-param.ts","../../../../src/factories/native-audio-buffer-source-node-factory.ts","../../../../src/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.ts","../../../../src/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.ts","../../../../src/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.ts","../../../../src/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.ts","../../../../src/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.ts","../../../../src/factories/render-automation.ts","../../../../src/factories/get-audio-param-renderer.ts","../../../../src/factories/audio-buffer-source-node-renderer-factory.ts","../../../../src/factories/audio-param-factory.ts","../../../../src/factories/audio-param-renderer.ts","../../../../src/helpers/set-value-at-time-until-possible.ts","../../../../src/factories/audio-destination-node-constructor.ts","../../../../src/factories/audio-destination-node-renderer-factory.ts","../../../../src/factories/native-audio-destination-node.ts","../../../../src/factories/biquad-filter-node-renderer-factory.ts","../../../../src/factories/set-audio-node-tail-time.ts","../../../../src/factories/monitor-connections.ts","../../../../src/factories/native-channel-merger-node-factory.ts","../../../../src/factories/channel-merger-node-renderer-factory.ts","../../../../src/factories/channel-splitter-node-renderer-factory.ts","../../../../src/helpers/sanitize-channel-splitter-options.ts","../../../../src/factories/native-constant-source-node-faker-factory.ts","../../../../src/factories/native-constant-source-node-factory.ts","../../../../src/factories/constant-source-node-renderer-factory.ts","../../../../src/factories/native-convolver-node-factory.ts","../../../../src/factories/convolver-node-renderer-factory.ts","../../../../src/factories/delay-node-renderer-factory.ts","../../../../src/factories/dynamics-compressor-node-renderer-factory.ts","../../../../src/factories/gain-node-renderer-factory.ts","../../../../src/factories/render-native-offline-audio-context.ts","../../../../src/factories/test-offline-audio-context-current-time-support.ts","../../../../src/helpers/wrap-iir-filter-node-get-frequency-response-method.ts","../../../../src/factories/audio-listener-factory.ts","../../../../src/factories/minimal-base-audio-context-constructor.ts","../../../../src/factories/native-oscillator-node-factory.ts","../../../../src/factories/oscillator-node-renderer-factory.ts","../../../../src/factories/native-wave-shaper-node-faker-factory.ts","../../../../src/factories/native-wave-shaper-node-factory.ts","../../../../src/factories/native-panner-node-faker-factory.ts","../../../../src/factories/panner-node-renderer-factory.ts","../../../../src/factories/native-periodic-wave-factory.ts","../../../../src/helpers/sanitize-periodic-wave-options.ts","../../../../src/factories/native-stereo-panner-node-factory.ts","../../../../src/factories/native-stereo-panner-node-faker-factory.ts","../../../../src/factories/stereo-panner-node-renderer-factory.ts","../../../../src/factories/wave-shaper-node-renderer-factory.ts","../../../../src/factories/is-secure-context.ts","../../../../src/factories/expose-current-frame-and-current-time.ts","../../../../src/factories/get-or-create-backup-offline-audio-context.ts","../../../../src/factories/native-audio-worklet-node-constructor.ts","../../../../src/factories/evaluate-source.ts","../../../../src/factories/abort-error.ts","../../../../src/factories/test-audio-worklet-processor-post-message-support.ts","../../../../src/factories/is-native-context.ts","../../../../src/factories/decode-audio-data.ts","../../../../src/helpers/detach-array-buffer.ts","../../../../src/factories/data-clone-error.ts","../../../../src/factories/encoding-error.ts","../../../../src/factories/media-element-audio-source-node-constructor.ts","../../../../src/factories/native-media-element-audio-source-node.ts","../../../../src/factories/native-media-stream-audio-destination-node.ts","../../../../src/factories/media-stream-audio-source-node-constructor.ts","../../../../src/factories/native-media-stream-audio-source-node.ts","../../../../src/factories/media-stream-track-audio-source-node-constructor.ts","../../../../src/factories/native-media-stream-track-audio-source-node-factory.ts","../../../../src/factories/audio-context-constructor.ts","../../../../src/factories/connect-multiple-outputs.ts","../../../../src/factories/delete-unrendered-audio-worklet-node.ts","../../../../src/factories/get-active-audio-worklet-node-inputs.ts","../../../../src/factories/native-audio-worklet-node-faker-factory.ts","../../../../src/helpers/create-audio-worklet-processor.ts","../../../../src/factories/native-audio-worklet-node-factory.ts","../../../../src/helpers/test-clonability-of-audio-worklet-node-options.ts","../../../../src/factories/get-backup-offline-audio-context.ts","../../../../src/factories/set-active-audio-worklet-node-inputs.ts","../../../../src/helpers/sanitize-audio-worklet-node-options.ts","../../../../src/factories/minimal-audio-context-constructor.ts","../../../../src/factories/create-native-offline-audio-context.ts","../../../../src/factories/start-rendering.ts","../node_modules/regenerator-runtime/runtime.js","../node_modules/@babel/runtime/helpers/slicedToArray.js","../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/nonIterableRest.js","../node_modules/@babel/runtime/helpers/classCallCheck.js","../node_modules/@babel/runtime/helpers/createClass.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","prototype","_inherits","subClass","superClass","create","constructor","value","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_typeof","obj","Symbol","iterator","_possibleConstructorReturn","self","call","assertThisInitialized","_createSuper","Derived","hasNativeReflectConstruct","isNativeReflectConstruct","result","Super","NewTarget","this","Reflect","construct","module","exports","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","error","done","Promise","then","_asyncToGenerator","fn","args","err","undefined","_assertThisInitialized","ReferenceError","_createForOfIteratorHelper","allowArrayLike","it","Array","isArray","F","s","n","e","_e","f","normalCompletion","didErr","step","next","_e2","_toConsumableArray","arr","arrayLikeToArray","iter","from","unsupportedIterableToArray","_defineProperty","_setPrototypeOf","p","_isNativeReflectConstruct","sham","Proxy","Date","toString","_slicedToArray","_interopDefaultLegacy","_slicedToArray__default","_classCallCheck__default","_createClass__default","createExtendedExponentialRampToValueAutomationEvent","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","interpolateValue","theoreticIndex","lowerIndex","floor","upperIndex","ceil","getValueCurveValueAtTime","isSetTargetAutomationEvent","AutomationEventList","_automationEvents","_currenTime","_defaultValue","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","Error","startValue","truncatedAutomationEvent","getValue","Float32Array","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","factory","require","IMPORT_STATEMENT_REGEX","matchingElements","MOST_NEGATIVE_SINGLE_FLOAT","analyzer","_map","createNestedArrays","x","arrays","filterBuffer","assignNativeAudioNodeOption","assignNativeAudioNodeAudioParamValue","computeBufferSize","baseLatency","_objectWithoutProperties","excluded","sourceKeys","indexOf","sourceSymbolKeys","propertyIsEnumerable","audioNode","connect","_nativeAnalyserNode","nativeAudioScheduledSourceNode","start","nativeAudioBufferSourceNode","when","automationEventList","add","nativeAudioParam","channelMergerNode","nativeConstantSourceNode","options","channelCount","createNotSupportedError","nativeContext","upZ","_onstatechange","_oscillatorNodeRenderer","oversample","pannerNode","nativePannerNode","a","arrayBuffer","MessageChannel","port1","nativeAudioContext","runtime","Op","hasOwn","hasOwnProperty","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","GenStateSuspendedStart","method","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","GenStateSuspendedYield","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","__await","unwrapped","previousPromise","callInvokeWithMethodAndArg","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","name","mark","awrap","async","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","arrayWithHoles","iterableToArrayLimit","nonIterableRest","_arr","_n","_d","_s","_i","minLen","test","len","arr2"],"mappings":"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","file":"static/js/0.ce88f912.chunk.js","sourcesContent":["import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","module.exports = require(\"regenerator-runtime\");\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n}(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);\n    var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\n    var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n          target = _ref.target,\n          timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n\n      if (valueAtStartTime === value) {\n        return value;\n      }\n\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n          startTime = _ref.startTime,\n          values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList = /*#__PURE__*/function () {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck__default['default'](this, AutomationEventList);\n\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n\n      _createClass__default['default'](AutomationEventList, [{\n        key: Symbol.iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n              }\n\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n\n            var removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n\n                var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n\n          var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n          var index = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n\n          var nextAutomationEvent = this._automationEvents[index];\n          var currentAutomationEvent = getEventTime(lastAutomationEvent) <= time ? lastAutomationEvent : this._automationEvents[index - 1];\n\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf2 = _slicedToArray__default['default'](_getEndTimeAndValueOf, 2),\n                startTime = _getEndTimeAndValueOf2[0],\n                value = _getEndTimeAndValueOf2[1];\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf4 = _slicedToArray__default['default'](_getEndTimeAndValueOf3, 2),\n                _startTime = _getEndTimeAndValueOf4[0],\n                _value = _getEndTimeAndValueOf4[1];\n\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n\n          return this._defaultValue;\n        }\n      }]);\n\n      return AutomationEventList;\n    }();\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const EVENT_LISTENERS = new WeakMap();\nexport const CYCLE_COUNTERS = new WeakMap();\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();\n//# sourceMappingURL=globals.js.map","const handler = {\n    construct() {\n        return handler;\n    }\n};\nexport const isConstructible = (constructible) => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=is-constructible.js.map","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\nexport const splitImportStatements = (source, url) => {\n    const importStatements = [];\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n//# sourceMappingURL=split-import-statements.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\nexport const createAddAudioWorkletModule = (cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) => {\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const nativeContext = getNativeContext(context);\n        // Bug #59: Safari does not implement the audioWorklet property.\n        if (nativeContext.audioWorklet !== undefined) {\n            return Promise.all([\n                fetchSource(moduleURL),\n                Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))\n            ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                 *\n                 * This is the unminified version of the code used below.\n                 *\n                 * ```js\n                 * class extends AudioWorkletProcessor {\n                 *\n                 *     __buffers = new WeakSet();\n                 *\n                 *     constructor () {\n                 *         super();\n                 *\n                 *         this.port.postMessage = ((postMessage) => {\n                 *             return (message, transferables) => {\n                 *                 const filteredTransferables = (transferables)\n                 *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                 *                     : transferables;\n                 *\n                 *                 return postMessage.call(this.port, message, filteredTransferables);\n                 *              };\n                 *         })(this.port.postMessage);\n                 *     }\n                 * }\n                 * ```\n                 */\n                const patchedSourceWithoutImportStatements = isSupportingPostMessage\n                    ? sourceWithoutImportStatements\n                    : sourceWithoutImportStatements.replace(/\\s+extends\\s+AudioWorkletProcessor\\s*{/, ` extends (class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}){`);\n                /*\n                 * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                 *\n                 * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *     __collectBuffers = (array) => {\n                 *         array.forEach((element) => this.__buffers.add(element.buffer));\n                 *     };\n                 *\n                 *     process (inputs, outputs, parameters) {\n                 *         inputs.forEach(this.__collectBuffers);\n                 *         outputs.forEach(this.__collectBuffers);\n                 *         this.__collectBuffers(Object.values(parameters));\n                 *\n                 *         return super.process(\n                 *             (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                 *             outputs,\n                 *             parameters\n                 *         );\n                 *     }\n                 *\n                 * }))`\n                 * ```\n                 */\n                const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                const bufferRegistration = isSupportingPostMessage\n                    ? ''\n                    : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                const wrappedSource = `${importStatements};(registerProcessor=>{${patchedSourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`;\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                return nativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => {\n                    if (isNativeOfflineAudioContext(nativeContext)) {\n                        return;\n                    }\n                    // Bug #186: Chrome, Edge and Opera do not allow to create an AudioWorkletNode on a closed AudioContext.\n                    const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n                    return backupOfflineAudioContext.audioWorklet.addModule(url, options);\n                })\n                    .finally(() => URL.revokeObjectURL(url));\n            });\n        }\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const promise = fetchSource(moduleURL)\n            .then(([source, absoluteUrl]) => {\n            const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n            /*\n             * This is the unminified version of the code used below:\n             *\n             * ```js\n             * ${ importStatements };\n             * ((a, b) => {\n             *     (a[b] = a[b] || [ ]).push(\n             *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n             *             ${ sourceWithoutImportStatements }\n             *         }\n             *     );\n             * })(window, '_AWGS');\n             * ```\n             */\n            // tslint:disable-next-line:max-line-length\n            const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n            // @todo Evaluating the given source code is a possible security problem.\n            return evaluateSource(wrappedSource);\n        })\n            .then(() => {\n            const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n            if (evaluateAudioWorkletGlobalScope === undefined) {\n                // Bug #182 Chrome, Edge and Opera do throw an instance of a SyntaxError instead of a DOMException.\n                throw new SyntaxError();\n            }\n            exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n            }, undefined, (name, processorCtor) => {\n                if (name.trim() === '') {\n                    throw createNotSupportedError();\n                }\n                const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                if (nodeNameToProcessorConstructorMap !== undefined) {\n                    if (nodeNameToProcessorConstructorMap.has(name)) {\n                        throw createNotSupportedError();\n                    }\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                }\n                else {\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                }\n            }, nativeContext.sampleRate, undefined, undefined));\n        });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const rslvdRqstsFCntxt = resolvedRequests.get(context);\n            if (rslvdRqstsFCntxt === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                rslvdRqstsFCntxt.add(moduleURL);\n            }\n        })\n            .finally(() => {\n            const ngngRqstsFCntxt = ongoingRequests.get(context);\n            if (ngngRqstsFCntxt !== undefined) {\n                ngngRqstsFCntxt.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=add-audio-worklet-module.js.map","export const getValueForKey = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n    return value;\n};\n//# sourceMappingURL=get-value-for-key.js.map","export const pickElementFromSet = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n    const [matchingElement] = matchingElements;\n    set.delete(matchingElement);\n    return matchingElement;\n};\n//# sourceMappingURL=pick-element-from-set.js.map","import { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\nexport const deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input);\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\n//# sourceMappingURL=delete-passive-input-connection-to-audio-node.js.map","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n//# sourceMappingURL=get-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToActive = (audioNode) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n//# sourceMappingURL=set-internal-state-to-active.js.map","export const isAudioWorkletNode = (audioNode) => {\n    return 'port' in audioNode;\n};\n//# sourceMappingURL=audio-worklet-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToPassive = (audioNode) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n//# sourceMappingURL=set-internal-state-to-passive.js.map","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=set-internal-state-to-passive-when-necessary.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class AnalyserNode extends audionNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null));\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n        get fftSize() {\n            return this._nativeAnalyserNode.fftSize;\n        }\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n        get frequencyBinCount() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n        get maxDecibels() {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get minDecibels() {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get smoothingTimeConstant() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n        getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n        getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n        getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n        getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n//# sourceMappingURL=analyser-node-constructor.js.map","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n    return nativeAudioNode.context === nativeContext;\n};\n//# sourceMappingURL=is-owned-by-context.js.map","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-copy-channel-methods-out-of-bounds-support.js.map","export const createIndexSizeError = () => new DOMException('', 'IndexSizeError');\n//# sourceMappingURL=index-size-error.js.map","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            }\n            catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n//# sourceMappingURL=wrap-audio-buffer-get-channel-data-method.js.map","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        static [Symbol.hasInstance](instance) {\n            return ((instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=audio-buffer-constructor.js.map","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n//# sourceMappingURL=constants.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n//# sourceMappingURL=is-active-audio-node.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class AudioBufferSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline ? createAudioBufferSourceNodeRenderer() : null));\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n            // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-buffer-source-node-constructor.js.map","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n//# sourceMappingURL=get-audio-node-connections.js.map","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioParamConnections = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n//# sourceMappingURL=get-audio-param-connections.js.map","import { isAudioBufferSourceNode } from '../guards/audio-buffer-source-node';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { isBiquadFilterNode } from '../guards/biquad-filter-node';\nimport { isConstantSourceNode } from '../guards/constant-source-node';\nimport { isGainNode } from '../guards/gain-node';\nimport { isOscillatorNode } from '../guards/oscillator-node';\nimport { isStereoPannerNode } from '../guards/stereo-panner-node';\nimport { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nimport { isActiveAudioNode } from './is-active-audio-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\nexport const deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {\n    const { activeInputs } = getAudioNodeConnections(audioNode);\n    activeInputs.forEach((connections) => connections.forEach(([source]) => {\n        if (!trace.includes(audioNode)) {\n            deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n        }\n    }));\n    const audioParams = isAudioBufferSourceNode(audioNode)\n        ? [\n            // Bug #149: Safari does not yet support the detune AudioParam.\n            audioNode.playbackRate\n        ]\n        : isAudioWorkletNode(audioNode)\n            ? Array.from(audioNode.parameters.values())\n            : isBiquadFilterNode(audioNode)\n                ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain]\n                : isConstantSourceNode(audioNode)\n                    ? [audioNode.offset]\n                    : isGainNode(audioNode)\n                        ? [audioNode.gain]\n                        : isOscillatorNode(audioNode)\n                            ? [audioNode.detune, audioNode.frequency]\n                            : isStereoPannerNode(audioNode)\n                                ? [audioNode.pan]\n                                : [];\n    for (const audioParam of audioParams) {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n        }\n    }\n    if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=deactivate-active-audio-node-input-connections.js.map","export const isAudioBufferSourceNode = (audioNode) => {\n    return 'playbackRate' in audioNode;\n};\n//# sourceMappingURL=audio-buffer-source-node.js.map","export const isBiquadFilterNode = (audioNode) => {\n    return 'frequency' in audioNode && 'gain' in audioNode;\n};\n//# sourceMappingURL=biquad-filter-node.js.map","export const isConstantSourceNode = (audioNode) => {\n    return 'offset' in audioNode;\n};\n//# sourceMappingURL=constant-source-node.js.map","export const isGainNode = (audioNode) => {\n    return !('frequency' in audioNode) && 'gain' in audioNode;\n};\n//# sourceMappingURL=gain-node.js.map","export const isOscillatorNode = (audioNode) => {\n    return 'detune' in audioNode && 'frequency' in audioNode;\n};\n//# sourceMappingURL=oscillator-node.js.map","export const isStereoPannerNode = (audioNode) => {\n    return 'pan' in audioNode;\n};\n//# sourceMappingURL=stereo-panner-node.js.map","import { deactivateActiveAudioNodeInputConnections } from './deactivate-active-audio-node-input-connections';\nexport const deactivateAudioGraph = (context) => {\n    deactivateActiveAudioNodeInputConnections(context.destination, []);\n};\n//# sourceMappingURL=deactivate-audio-graph.js.map","export const isValidLatencyHint = (latencyHint) => {\n    return (latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback')));\n};\n//# sourceMappingURL=is-valid-latency-hint.js.map","export const isAudioNode = (audioNodeOrAudioParam) => {\n    return 'context' in audioNodeOrAudioParam;\n};\n//# sourceMappingURL=audio-node.js.map","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = (outputConnection) => {\n    return isAudioNode(outputConnection[0]);\n};\n//# sourceMappingURL=audio-node-output-connection.js.map","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n    set.add(element);\n    return true;\n};\n//# sourceMappingURL=insert-element-in-set.js.map","import { insertElementInSet } from './insert-element-in-set';\nexport const addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\n//# sourceMappingURL=add-active-input-connection-to-audio-param.js.map","import { insertElementInSet } from './insert-element-in-set';\nexport const addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);\n    }\n};\n//# sourceMappingURL=add-passive-input-connection-to-audio-param.js.map","export const isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n//# sourceMappingURL=native-audio-node-faker.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n    return [nativeDestinationAudioNode, output, input];\n};\n//# sourceMappingURL=connect-native-audio-node-to-native-audio-node.js.map","export const deleteActiveInputConnection = (activeInputConnections, source, output) => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n            return activeInputConnection;\n        }\n    }\n    return null;\n};\n//# sourceMappingURL=delete-active-input-connection.js.map","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n//# sourceMappingURL=delete-event-listeners-of-audio-node.js.map","import { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\nexport const deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\n//# sourceMappingURL=delete-passive-input-connection-to-audio-param.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    }\n    else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n//# sourceMappingURL=disconnect-native-audio-node-from-native-audio-node.js.map","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n//# sourceMappingURL=get-native-audio-node.js.map","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n//# sourceMappingURL=get-native-audio-param.js.map","import { CYCLE_COUNTERS } from '../globals';\nexport const isPartOfACycle = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n//# sourceMappingURL=is-part-of-a-cycle.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=is-passive-audio-node.js.map","export const testAudioNodeDisconnectMethodSupport = (nativeAudioContext) => {\n    return new Promise((resolve) => {\n        const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n        const dummy = nativeAudioContext.createGain();\n        // Bug #95: Safari does not play one sample buffers.\n        const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n        const channelData = ones.getChannelData(0);\n        channelData[0] = 1;\n        channelData[1] = 1;\n        const source = nativeAudioContext.createBufferSource();\n        source.buffer = ones;\n        source.loop = true;\n        source.connect(analyzer).connect(nativeAudioContext.destination);\n        source.connect(dummy);\n        source.disconnect(dummy);\n        // tslint:disable-next-line:deprecation\n        analyzer.onaudioprocess = (event) => {\n            const chnnlDt = event.inputBuffer.getChannelData(0);\n            if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n            source.stop();\n            analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n            source.disconnect(analyzer);\n            analyzer.disconnect(nativeAudioContext.destination);\n        };\n        source.start();\n    });\n};\n//# sourceMappingURL=test-audio-node-disconnect-method-support.js.map","export const visitEachAudioNodeOnce = (cycles, visitor) => {\n    const counts = new Map();\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n//# sourceMappingURL=visit-each-audio-node-once.js.map","export const isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n//# sourceMappingURL=native-audio-node.js.map","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, isOffline, destination, output) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source, isOffline) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n        destinations.push(outputConnection[0]);\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n    return destinations;\n};\nconst deleteConnectionAtOutput = (source, isOffline, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n    return destinations;\n};\nconst deleteConnectionToDestination = (source, isOffline, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => outputConnection[0] === destination &&\n        (output === undefined || outputConnection[1] === output) &&\n        (input === undefined || outputConnection[2] === input))\n        .map((outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return outputConnection[0];\n    });\n};\nexport const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n    return class AudioNode extends eventTargetConstructor {\n        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext);\n                    })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        // tslint:disable-next-line:invalid-void\n        connect(destination, output = 0, input = 0) {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    const isPassive = isPassiveAudioNode(this);\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err;\n                }\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], destination);\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari.\n             */\n            if (nativeAudioParam.name === 'playbackRate') {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Only Firefox does throw an InvalidStateError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err;\n            }\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            let destinations;\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-node-constructor.js.map","import { pickElementFromSet } from './pick-element-from-set';\nexport const deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n    return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\n//# sourceMappingURL=delete-active-input-connection-to-audio-param.js.map","export class ReadOnlyMap {\n    constructor(parameters) {\n        this._map = new Map(parameters);\n    }\n    get size() {\n        return this._map.size;\n    }\n    entries() {\n        return this._map.entries();\n    }\n    forEach(callback, thisArg = null) {\n        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n    }\n    get(name) {\n        return this._map.get(name);\n    }\n    has(name) {\n        return this._map.has(name);\n    }\n    keys() {\n        return this._map.keys();\n    }\n    values() {\n        return this._map.values();\n    }\n}\n//# sourceMappingURL=read-only-map.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options) {\n            var _a;\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n            // Bug #186: Chrome, Edge and Opera do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed'\n                ? nativeContext\n                : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null));\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, this);\n            }\n            const { activeInputs } = getAudioNodeConnections(this);\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=audio-worklet-node-constructor.js.map","export function copyFromChannel(audioBuffer, \n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n    }\n    else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        }\n        else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n            parent[key].set(slicedInput);\n        }\n    }\n}\n//# sourceMappingURL=copy-from-channel.js.map","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n    }\n    else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n//# sourceMappingURL=copy-to-channel.js.map","export const createNestedArrays = (x, y) => {\n    const arrays = [];\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n        const length = typeof y === 'number' ? y : y[i];\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n    }\n    return arrays;\n};\n//# sourceMappingURL=create-nested-arrays.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=get-audio-worklet-processor.js.map","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                colno: error.colno,\n                filename: error.filename,\n                lineno: error.lineno,\n                message: error.message\n            }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n            // Bug #61: Only Chrome, Edge, Firefox & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-worklet-node-renderer-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class BiquadFilterNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = (isOffline ? createBiquadFilterNodeRenderer() : null);\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n            // Bug #80: Safari does not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));\n            // Bug #77: Firefox & Safari do not export the correct value for minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get gain() {\n            return this._gain;\n        }\n        get Q() {\n            return this._Q;\n        }\n        get type() {\n            return this._nativeBiquadFilterNode.type;\n        }\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n                this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            }\n            catch (err) {\n                if (err.code === 11) {\n                    throw createInvalidAccessError();\n                }\n                throw err;\n            }\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n//# sourceMappingURL=biquad-filter-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class ChannelMergerNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null));\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=channel-merger-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n};\nexport const createChannelSplitterNodeConstructor = (audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions) => {\n    return class ChannelSplitterNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizeChannelSplitterOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = ((isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null));\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=channel-splitter-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n};\nexport const createConstantSourceNodeConstructor = (audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class ConstantSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = ((isOffline ? createConstantSourceNodeRendererFactory() : null));\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n             * for GainNodes.\n             */\n            this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._onended = null;\n        }\n        get offset() {\n            return this._offset;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        start(when = 0) {\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=constant-source-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class ConvolverNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = (isOffline ? createConvolverNodeRenderer() : null);\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n            if (mergedOptions.buffer !== null) {\n                setAudioNodeTailTime(this, mergedOptions.buffer.duration);\n            }\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeConvolverNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, 44100);\n                this._isBufferNullified = true;\n                setAudioNodeTailTime(this, 0);\n            }\n            else {\n                this._isBufferNullified = false;\n                setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n        }\n        get normalize() {\n            return this._nativeConvolverNode.normalize;\n        }\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n//# sourceMappingURL=convolver-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class DelayNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = (isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null);\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime);\n            setAudioNodeTailTime(this, mergedOptions.maxDelayTime);\n        }\n        get delayTime() {\n            return this._delayTime;\n        }\n    };\n};\n//# sourceMappingURL=delay-node-constructor.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n    return outputAudioNode;\n};\nexport const createDisconnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n//# sourceMappingURL=disconnect-multiple-outputs.js.map","const DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class DynamicsCompressorNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = (isOffline ? createDynamicsCompressorNodeRenderer() : null);\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold);\n            setAudioNodeTailTime(this, 0.006);\n        }\n        get attack() {\n            return this._attack;\n        }\n        // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        get channelCount() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        /*\n         * Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        get knee() {\n            return this._knee;\n        }\n        get ratio() {\n            return this._ratio;\n        }\n        get reduction() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n                return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n        get release() {\n            return this._release;\n        }\n        get threshold() {\n            return this._threshold;\n        }\n    };\n};\n//# sourceMappingURL=dynamics-compressor-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n};\nexport const createGainNodeConstructor = (audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class GainNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = (isOffline ? createGainNodeRenderer() : null);\n            super(context, false, nativeGainNode, gainNodeRenderer);\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get gain() {\n            return this._gain;\n        }\n    };\n};\n//# sourceMappingURL=gain-node-constructor.js.map","export const createInvalidStateError = () => new DOMException('', 'InvalidStateError');\n//# sourceMappingURL=invalid-state-error.js.map","export const createInvalidAccessError = () => new DOMException('', 'InvalidAccessError');\n//# sourceMappingURL=invalid-access-error.js.map","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class IIRFilterNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n            const iirFilterNodeRenderer = ((isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null));\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n//# sourceMappingURL=iir-filter-node-constructor.js.map","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n    const inputLength = input.length;\n    let i = bufferIndex;\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n        output[j] = y;\n    }\n    return i;\n};\n//# sourceMappingURL=filter-buffer.js.map","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (convertedFeedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            convertedFeedback[i] /= convertedFeedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let filteredBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    proxy.context.destination.channelCount, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n                const filteredBuffer = await filteredBufferPromise;\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=iir-filter-node-renderer-factory.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n};\nexport const createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioDestinationNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n            super(context, false, nativeMediaStreamAudioDestinationNode, null);\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n        get stream() {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n//# sourceMappingURL=media-stream-audio-destination-node-constructor.js.map","export const testPromiseSupport = (nativeContext) => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n        if (promise === undefined) {\n            return false;\n        }\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n        return true;\n    }\n    catch {\n        // Ignore errors.\n    }\n    return false;\n};\n//# sourceMappingURL=test-promise-support.js.map","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n                deactivateAudioGraph(this);\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=minimal-offline-audio-context-constructor.js.map","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n    const value = options[option];\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n//# sourceMappingURL=assign-native-audio-node-option.js.map","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n//# sourceMappingURL=assign-native-audio-node-options.js.map","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n//# sourceMappingURL=test-analyser-node-get-float-time-domain-data-method-support.js.map","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n    const value = options[audioParam];\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n//# sourceMappingURL=assign-native-audio-node-audio-param-value.js.map","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-start-method-negative-parameters.js.map","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-stop-method-negative-parameters.js.map","export const computeBufferSize = (baseLatency, sampleRate) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n//# sourceMappingURL=compute-buffer-size.js.map","export const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n            reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n//# sourceMappingURL=clone-audio-worklet-node-options.js.map","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n//# sourceMappingURL=create-audio-worklet-processor-promise.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNode = (nativeContext, options) => {\n    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n    return nativeBiquadFilterNode;\n};\n//# sourceMappingURL=native-biquad-filter-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNode = (nativeContext, options) => {\n    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n    // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Safari does not have the correct channelCountMode.\n    // Bug #31: Safari does not have the correct channelInterpretation.\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n    // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge, Firefox & Opera partially support the spec yet.\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n    return nativeChannelSplitterNode;\n};\n//# sourceMappingURL=native-channel-splitter-node.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = (channelSplitterNode) => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n//# sourceMappingURL=wrap-channel-splitter-node.js.map","import objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","export const interceptConnections = (original, interceptor) => {\n    original.connect = interceptor.connect.bind(interceptor);\n    original.disconnect = interceptor.disconnect.bind(interceptor);\n    return original;\n};\n//# sourceMappingURL=intercept-connections.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNode = (nativeContext, options) => {\n    const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n    return nativeDelayNode;\n};\n//# sourceMappingURL=native-delay-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNode = (nativeContext, options) => {\n    const nativeGainNode = nativeContext.createGain();\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n    return nativeGainNode;\n};\n//# sourceMappingURL=native-gain-node.js.map","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nfunction divide(a, b) {\n    const denominator = b[0] * b[0] + b[1] * b[1];\n    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\nfunction multiply(a, b) {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\nfunction evaluatePolynomial(coefficient, z) {\n    let result = [0, 0];\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n    }\n    return result;\n}\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        const feedbackLength = convertedFeedback.length;\n        const feedforwardLength = convertedFeedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedbackLength === 0 || feedbackLength > 20) {\n            throw createNotSupportedError();\n        }\n        if (convertedFeedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n            throw createNotSupportedError();\n        }\n        if (convertedFeedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (convertedFeedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                convertedFeedforward[i] /= convertedFeedback[0];\n            }\n            for (let i = 1; i < feedbackLength; i += 1) {\n                convertedFeedback[i] /= convertedFeedback[0];\n            }\n        }\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        const bufferLength = 32;\n        const bufferIndexes = [];\n        const xBuffers = [];\n        const yBuffers = [];\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = (event) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n            const numberOfChannels = inputBuffer.numberOfChannels;\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n                bufferIndexes[i] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n            }\n        };\n        const nyquist = nativeContext.sampleRate / 2;\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs() {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args) {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                    throw createInvalidAccessError();\n                }\n                const length = frequencyHz.length;\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(convertedFeedforward, z);\n                    const denominator = evaluatePolynomial(convertedFeedback, z);\n                    const response = divide(numerator, denominator);\n                    magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n//# sourceMappingURL=native-iir-filter-node-faker-factory.js.map","export const createAddActiveInputConnectionToAudioNode = (insertElementInSet) => {\n    return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n        insertElementInSet(activeInputs[input], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n    };\n};\n//# sourceMappingURL=add-active-input-connection-to-audio-node.js.map","export const createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet) => {\n    return (activeInputs, source, output, input) => {\n        return pickElementFromSet(activeInputs[input], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n    };\n};\n//# sourceMappingURL=delete-active-input-connection-to-audio-node.js.map","export const createCacheTestResult = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n        const ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n        try {\n            const synchronousTestResult = test();\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                    ongoingTests.delete(tester);\n                    testResults.set(tester, finalTestResult);\n                    return finalTestResult;\n                });\n            }\n            testResults.set(tester, synchronousTestResult);\n            return synchronousTestResult;\n        }\n        catch {\n            testResults.set(tester, false);\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=cache-test-result.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = nativeContext.createAnalyser();\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n    };\n};\n//# sourceMappingURL=native-analyser-node-factory.js.map","export const createGetAudioNodeRenderer = (getAudioNodeConnections) => {\n    return (audioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n        return audioNodeConnections.renderer;\n    };\n};\n//# sourceMappingURL=get-audio-node-renderer.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAnalyserNodes = new WeakMap();\n        const createAnalyserNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAnalyserNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode, trace);\n            return nativeAnalyserNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n                return createAnalyserNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=analyser-node-renderer-factory.js.map","import { createInvalidStateError } from './invalid-state-error';\nexport const createGetNativeContext = (contextStore) => {\n    return (context) => {\n        const nativeContext = contextStore.get(context);\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n        return (nativeContext);\n    };\n};\n//# sourceMappingURL=get-native-context.js.map","export const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor) => {\n    return (anything) => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n//# sourceMappingURL=is-native-offline-audio-context.js.map","export const createEventTargetConstructor = (wrapEventListener) => {\n    return class EventTarget {\n        constructor(_nativeEventTarget) {\n            this._nativeEventTarget = _nativeEventTarget;\n            this._listeners = new WeakMap();\n        }\n        addEventListener(type, listener, options) {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n        dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n        removeEventListener(type, listener, options) {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n//# sourceMappingURL=event-target-constructor.js.map","export const createIsNativeAudioContext = (nativeAudioContextConstructor) => {\n    return (anything) => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n//# sourceMappingURL=is-native-audio-context.js.map","export const createAddAudioNodeConnections = (audioNodeConnectionsStore) => {\n    return (audioNode, audioNodeRenderer, nativeAudioNode) => {\n        const activeInputs = [];\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set());\n        }\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n//# sourceMappingURL=add-audio-node-connections.js.map","export const createConvertNumberToUnsignedLong = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n        return unit32Array[0];\n    };\n};\n//# sourceMappingURL=convert-number-to-unsigned-long.js.map","// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=test-audio-buffer-constructor-support.js.map","export const createAddSilentConnection = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n//# sourceMappingURL=add-silent-connection.js.map","export const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {\n    return async (audioParam, nativeOfflineAudioContext, nativeAudioParam, trace) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, trace);\n            if (!isPartOfACycle(source)) {\n                renderedNativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }));\n    };\n};\n//# sourceMappingURL=render-inputs-of-audio-param.js.map","export const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n        overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', (get) => () => {\n            const value = get.call(nativeAudioBufferSourceNode);\n            return value === nullifiedBuffer ? null : value;\n        }, (set) => (value) => {\n            return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n        });\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-stop-method-nullified-buffer.js.map","export const createAddAudioParamConnections = (audioParamConnectionsStore) => {\n    return (audioParam, audioParamRenderer) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n//# sourceMappingURL=add-audio-param-connections.js.map","export const createWrapChannelMergerNode = (createInvalidStateError, monitorConnections) => {\n    return (nativeContext, channelMergerNode) => {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = nativeContext.createBufferSource();\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=wrap-channel-merger-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n    };\n};\n//# sourceMappingURL=native-dynamics-compressor-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        const nativeIIRFilterNode = nativeContext.createIIRFilter(options.feedforward, options.feedback);\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n    };\n};\n//# sourceMappingURL=native-iir-filter-node-factory.js.map","export const createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n//# sourceMappingURL=connected-native-audio-buffer-source-node-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = nativeContext.createPanner();\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n    };\n};\n//# sourceMappingURL=native-panner-node-factory.js.map","export const createFetchSource = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                return [await response.text(), response.url];\n            }\n        }\n        catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n        throw createAbortError();\n    };\n};\n//# sourceMappingURL=fetch-source.js.map","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n    return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext, numberOfChannels);\n            this._nativeContext = _nativeContext;\n            this._audioWorklet =\n                addAudioWorkletModule === undefined\n                    ? undefined\n                    : {\n                        addModule: (moduleURL, options) => {\n                            return addAudioWorkletModule(this, moduleURL, options);\n                        }\n                    };\n        }\n        get audioWorklet() {\n            return this._audioWorklet;\n        }\n        createAnalyser() {\n            return new analyserNodeConstructor(this);\n        }\n        createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n        }\n        createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n        createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n        }\n        createChannelMerger(numberOfInputs = 6) {\n            return new channelMergerNodeConstructor(this, { numberOfInputs });\n        }\n        createChannelSplitter(numberOfOutputs = 6) {\n            return new channelSplitterNodeConstructor(this, { numberOfOutputs });\n        }\n        createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n        }\n        createConvolver() {\n            return new convolverNodeConstructor(this);\n        }\n        createDelay(maxDelayTime = 1) {\n            return new delayNodeConstructor(this, { maxDelayTime });\n        }\n        createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n        }\n        createGain() {\n            return new gainNodeConstructor(this);\n        }\n        createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, { feedback, feedforward });\n        }\n        createOscillator() {\n            return new oscillatorNodeConstructor(this);\n        }\n        createPanner() {\n            return new pannerNodeConstructor(this);\n        }\n        createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {\n            return new periodicWaveConstructor(this, { ...constraints, imag, real });\n        }\n        createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n        }\n        createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n        }\n        decodeAudioData(audioData, successCallback, errorCallback) {\n            return decodeAudioData(this._nativeContext, audioData)\n                .then((audioBuffer) => {\n                if (typeof successCallback === 'function') {\n                    successCallback(audioBuffer);\n                }\n                return audioBuffer;\n            })\n                .catch((err) => {\n                if (typeof errorCallback === 'function') {\n                    errorCallback(err);\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=base-audio-context-constructor.js.map","export const createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n        return unrenderedAudioWorkletNodes;\n    };\n};\n//# sourceMappingURL=get-unrendered-audio-worklet-nodes.js.map","export const createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=add-unrendered-audio-worklet-node.js.map","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};\n//# sourceMappingURL=is-any-audio-node.js.map","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n    return (anything) => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};\n//# sourceMappingURL=is-any-audio-param.js.map","export const createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n};\n//# sourceMappingURL=native-script-processor-node.js.map","export const createNotSupportedError = () => new DOMException('', 'NotSupportedError');\n//# sourceMappingURL=not-supported-error.js.map","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n                deactivateAudioGraph(this);\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=offline-audio-context-constructor.js.map","import { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 440,\n    periodicWave: undefined,\n    type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class OscillatorNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = (isOffline ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n            // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Safari does not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                this._oscillatorNodeRenderer.periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeOscillatorNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        get type() {\n            return this._nativeOscillatorNode.type;\n        }\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n        setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n        start(when = 0) {\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=oscillator-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class PannerNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = (isOffline ? createPannerNodeRenderer() : null);\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n        get coneInnerAngle() {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n        get coneOuterAngle() {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n        get coneOuterGain() {\n            return this._nativePannerNode.coneOuterGain;\n        }\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n        get distanceModel() {\n            return this._nativePannerNode.distanceModel;\n        }\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n        get maxDistance() {\n            return this._nativePannerNode.maxDistance;\n        }\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n        get orientationX() {\n            return this._orientationX;\n        }\n        get orientationY() {\n            return this._orientationY;\n        }\n        get orientationZ() {\n            return this._orientationZ;\n        }\n        get panningModel() {\n            return this._nativePannerNode.panningModel;\n        }\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n        get positionX() {\n            return this._positionX;\n        }\n        get positionY() {\n            return this._positionY;\n        }\n        get positionZ() {\n            return this._positionZ;\n        }\n        get refDistance() {\n            return this._nativePannerNode.refDistance;\n        }\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n        get rolloffFactor() {\n            return this._nativePannerNode.rolloffFactor;\n        }\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n//# sourceMappingURL=panner-node-constructor.js.map","const DEFAULT_OPTIONS = {\n    disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave, getNativeContext, periodicWaveStore, sanitizePeriodicWaveOptions) => {\n    return class PeriodicWave {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizePeriodicWaveOptions({ ...DEFAULT_OPTIONS, ...options });\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n            periodicWaveStore.add(periodicWave);\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n        static [Symbol.hasInstance](instance) {\n            return ((instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype) ||\n                periodicWaveStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=periodic-wave-constructor.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n};\nexport const createStereoPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n    return class StereoPannerNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = (isOffline ? createStereoPannerNodeRenderer() : null);\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan);\n        }\n        get pan() {\n            return this._pan;\n        }\n    };\n};\n//# sourceMappingURL=stereo-panner-node-constructor.js.map","export const createUnknownError = () => new DOMException('', 'UnknownError');\n//# sourceMappingURL=unknown-error.js.map","const DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {\n    return class WaveShaperNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = (isOffline ? createWaveShaperNodeRenderer() : null);\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n        get curve() {\n            if (this._isCurveNullified) {\n                return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n        }\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            }\n            else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome, Edge and Opera will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n        get oversample() {\n            return this._nativeWaveShaperNode.oversample;\n        }\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n//# sourceMappingURL=wave-shaper-node-constructor.js.map","export const isDCCurve = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n    const length = curve.length;\n    if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n    }\n    return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};\n//# sourceMappingURL=is-dc-curve.js.map","export const overwriteAccessors = (object, property, createGetter, createSetter) => {\n    let prototype = Object.getPrototypeOf(object);\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n    const { get, set } = Object.getOwnPropertyDescriptor(prototype, property);\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n//# sourceMappingURL=overwrite-accessors.js.map","export const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n    try {\n        nativeAudioBufferSourceNode.start(-1);\n    }\n    catch (err) {\n        return err instanceof RangeError;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-start-method-negative-parameters-support.js.map","export const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n    try {\n        nativeAudioBufferSourceNode.stop();\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js.map","export const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n    try {\n        nativeAudioBufferSourceNode.stop(-1);\n    }\n    catch (err) {\n        return err instanceof RangeError;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-stop-method-negative-parameters-support.js.map","import { interceptConnections } from './intercept-connections';\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {\n    const nativeGainNode = nativeContext.createGain();\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                }\n                catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            }\n            else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map","export const wrapEventListener = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n//# sourceMappingURL=wrap-event-listener.js.map","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddActiveInputConnectionToAudioNode } from './factories/add-active-input-connection-to-audio-node';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddConnectionToAudioNode } from './factories/add-connection-to-audio-node';\nimport { createAddPassiveInputConnectionToAudioNode } from './factories/add-passive-input-connection-to-audio-node';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteActiveInputConnectionToAudioNode } from './factories/delete-active-input-connection-to-audio-node';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetActiveAudioWorkletNodeInputs } from './factories/get-active-audio-worklet-node-inputs';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioNodeTailTime } from './factories/get-audio-node-tail-time';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupOfflineAudioContext } from './factories/get-backup-offline-audio-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetOrCreateBackupOfflineAudioContext } from './factories/get-or-create-backup-offline-audio-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNode } from './factories/native-biquad-filter-node';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNode } from './factories/native-channel-splitter-node';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNode } from './factories/native-delay-node';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNode } from './factories/native-gain-node';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNode } from './factories/native-media-element-audio-source-node';\nimport { createNativeMediaStreamAudioDestinationNode } from './factories/native-media-stream-audio-destination-node';\nimport { createNativeMediaStreamAudioSourceNode } from './factories/native-media-stream-audio-source-node';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNode } from './factories/native-script-processor-node';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createSetActiveAudioWorkletNodeInputs } from './factories/set-active-audio-worklet-node-inputs';\nimport { createSetAudioNodeTailTime } from './factories/set-audio-node-tail-time';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestAudioWorkletProcessorPostMessageSupport } from './factories/test-audio-worklet-processor-post-message-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestConvolverNodeChannelCountSupport } from './factories/test-convolver-node-channel-count-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, CYCLE_COUNTERS } from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from './helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from './helpers/is-passive-audio-node';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { pickElementFromSet } from './helpers/pick-element-from-set';\nimport { sanitizeAudioWorkletNodeOptions } from './helpers/sanitize-audio-worklet-node-options';\nimport { sanitizeChannelSplitterOptions } from './helpers/sanitize-channel-splitter-options';\nimport { sanitizePeriodicWaveOptions } from './helpers/sanitize-periodic-wave-options';\nimport { setValueAtTimeUntilPossible } from './helpers/set-value-at-time-until-possible';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { testAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './helpers/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { testAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { testAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { testAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { testDomExceptionConstructorSupport } from './helpers/test-dom-exception-constructor-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\nexport { analyserNodeConstructor as AnalyserNode };\nconst audioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nexport { audioBufferConstructor as AudioBuffer };\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext);\nconst unrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet(), sanitizePeriodicWaveOptions);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\nconst backupOfflineAudioContextStore = new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule = isSecureContext\n    ? createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, createEvaluateSource(window), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, new WeakMap(), new WeakMap(), createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), \n    // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n    window)\n    : undefined;\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore = new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, wrapEventListener)\n    : undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor), testDomExceptionConstructorSupport, createTestIsSecureContextSupport(window), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n//# sourceMappingURL=module.js.map","export const createAddPassiveInputConnectionToAudioNode = (insertElementInSet) => {\n    return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n        const passiveInputConnections = passiveInputs.get(source);\n        if (passiveInputConnections === undefined) {\n            passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        }\n        else {\n            insertElementInSet(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);\n        }\n    };\n};\n//# sourceMappingURL=add-passive-input-connection-to-audio-node.js.map","export const createGetAudioNodeTailTime = (audioNodeTailTimeStore) => {\n    return (audioNode) => { var _a; return (_a = audioNodeTailTimeStore.get(audioNode)) !== null && _a !== void 0 ? _a : 0; };\n};\n//# sourceMappingURL=get-audio-node-tail-time.js.map","export const createWindow = () => (typeof window === 'undefined' ? null : window);\n//# sourceMappingURL=window.js.map","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n    };\n};\n//# sourceMappingURL=wrap-analyser-node-get-float-time-domain-data-method.js.map","export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        const nextTrace = [...trace, audioNode];\n        await Promise.all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array.from(connections)\n            .filter(([source]) => !nextTrace.includes(source))\n            .map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n            const destination = audioNode.context.destination;\n            if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=render-inputs-of-audio-node.js.map","export const createNativeOfflineAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;\n};\n//# sourceMappingURL=native-offline-audio-context-constructor.js.map","export const createNativeAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n    return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;\n};\n//# sourceMappingURL=native-audio-context-constructor.js.map","export const createIsNativeAudioNode = (window) => {\n    return (anything) => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n//# sourceMappingURL=is-native-audio-node.js.map","export const createIsNativeAudioParam = (window) => {\n    return (anything) => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n//# sourceMappingURL=is-native-audio-param.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        // tslint:disable-next-line:invalid-void\n        return (destination, output = 0, input = 0) => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input || input === undefined));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=wrap-audio-node-disconnect-method.js.map","import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nexport const createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode) => {\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n        const eventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            }\n            else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n                const tailTime = getAudioNodeTailTime(destination);\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                }\n                else {\n                    setTimeout(() => {\n                        if (isActiveAudioNode(destination)) {\n                            setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                        }\n                    }, tailTime * 1000);\n                }\n            }\n        };\n        if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n            eventListeners.add(eventListener);\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            }\n            else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=add-connection-to-audio-node.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                            disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                        }\n                        else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n                cycleCounters.set(audioNode, count);\n            }\n            else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n//# sourceMappingURL=increment-cycle-counter-factory.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    }\n                    else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        }\n        else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n//# sourceMappingURL=decrement-cycle-counter.js.map","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(chain, nextLink) {\n        const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n        const { outputs } = getAudioNodeConnections(audioNode);\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n//# sourceMappingURL=detect-cycles.js.map","export const isDelayNode = (audioNode) => {\n    return 'delayTime' in audioNode;\n};\n//# sourceMappingURL=delay-node.js.map","export const createNativeAudioBufferConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n    return null;\n};\n//# sourceMappingURL=native-audio-buffer-constructor.js.map","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-copy-channel-methods.js.map","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map","export const createConnectAudioParam = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n    };\n};\n//# sourceMappingURL=connect-audio-param.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=native-audio-buffer-source-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n        return (when = 0, offset = 0, duration) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-start-method-consecutive-calls.js.map","export const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.start();\n    try {\n        nativeAudioBufferSourceNode.start();\n    }\n    catch {\n        return true;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-start-method-consecutive-calls-support.js.map","export const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    try {\n        nativeAudioBufferSourceNode.start(0, 1);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-start-method-offset-clamping-support.js.map","export const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.start();\n    try {\n        nativeAudioBufferSourceNode.stop();\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-stop-method-nullified-buffer-support.js.map","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            }\n            else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-start-method-offset-clamping.js.map","export const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n        audioParamRenderer.replay(nativeAudioParam);\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n    };\n};\n//# sourceMappingURL=render-automation.js.map","export const createGetAudioParamRenderer = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n        return audioParamConnections.renderer;\n    };\n};\n//# sourceMappingURL=get-audio-param-renderer.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n            }\n            else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode, trace);\n            return nativeAudioBufferSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-buffer-source-node-renderer-factory.js.map","import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array.from(automationEventList).pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=audio-param-factory.js.map","export const createAudioParamRenderer = (automationEventList) => {\n    return {\n        replay(audioParam) {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                }\n                else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n                    audioParam.setValueAtTime(value, startTime);\n                }\n                else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-param-renderer.js.map","export const setValueAtTimeUntilPossible = (audioParam, value, startTime) => {\n    try {\n        audioParam.setValueAtTime(value, startTime);\n    }\n    catch (err) {\n        if (err.code !== 9) {\n            throw err;\n        }\n        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n    }\n};\n//# sourceMappingURL=set-value-at-time-until-possible.js.map","export const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {\n    return class AudioDestinationNode extends audioNodeConstructor {\n        constructor(context, channelCount) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = ((isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null));\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n        get channelCount() {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge, Opera & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n        get maxChannelCount() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n//# sourceMappingURL=audio-destination-node-constructor.js.map","export const createAudioDestinationNodeRenderer = (renderInputsOfAudioNode) => {\n    let nativeAudioDestinationNodePromise = null;\n    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext, trace) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode, trace);\n        return nativeAudioDestinationNode;\n    };\n    return {\n        render(proxy, nativeOfflineAudioContext, trace) {\n            if (nativeAudioDestinationNodePromise === null) {\n                nativeAudioDestinationNodePromise = createAudioDestinationNode(proxy, nativeOfflineAudioContext, trace);\n            }\n            return nativeAudioDestinationNodePromise;\n        }\n    };\n};\n//# sourceMappingURL=audio-destination-node-renderer-factory.js.map","export const createNativeAudioDestinationNodeFactory = (createNativeGainNode, overwriteAccessors) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            }\n            catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n        overwriteAccessors(gainNode, 'channelCount', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            try {\n                nativeAudioDestinationNode.channelCount = value;\n            }\n            catch (err) {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                if (value > nativeAudioDestinationNode.maxChannelCount) {\n                    throw err;\n                }\n            }\n        });\n        overwriteAccessors(gainNode, 'channelCountMode', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelCountMode = value;\n        });\n        overwriteAccessors(gainNode, 'channelInterpretation', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelInterpretation = value;\n        });\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n        return gainNode;\n    };\n};\n//# sourceMappingURL=native-audio-destination-node.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createBiquadFilterNodeRendererFactory = (connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeBiquadFilterNodes = new WeakMap();\n        const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode, trace);\n            return nativeBiquadFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=biquad-filter-node-renderer-factory.js.map","export const createSetAudioNodeTailTime = (audioNodeTailTimeStore) => {\n    return (audioNode, tailTime) => audioNodeTailTimeStore.set(audioNode, tailTime);\n};\n//# sourceMappingURL=set-audio-node-tail-time.js.map","export const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set();\n        nativeAudioNode.connect = ((connect) => {\n            // tslint:disable-next-line:invalid-void\n            return (destination, output = 0, input = 0) => {\n                const wasDisconnected = connections.size === 0;\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    connect.call(nativeAudioNode, destination, output, input);\n                    insertElementInSet(connections, [destination, output, input], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input, true);\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n                    return destination;\n                }\n                connect.call(nativeAudioNode, destination, output);\n                insertElementInSet(connections, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n                return;\n            };\n        })(nativeAudioNode.connect);\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput, output, input) => {\n                const wasConnected = connections.size > 0;\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n                    connections.clear();\n                }\n                else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    disconnect.call(nativeAudioNode, destinationOrOutput);\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n                    }\n                    else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output);\n                    }\n                    for (const connection of connections) {\n                        if (connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                const isDisconnected = connections.size === 0;\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n        return nativeAudioNode;\n    };\n};\n//# sourceMappingURL=monitor-connections.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor, wrapChannelMergerNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        return nativeChannelMergerNode;\n    };\n};\n//# sourceMappingURL=native-channel-merger-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=channel-merger-node-renderer-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=channel-splitter-node-renderer-factory.js.map","export const sanitizeChannelSplitterOptions = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\n//# sourceMappingURL=sanitize-channel-splitter-options.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return [];\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-constant-source-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n    return (nativeContext, options) => {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        const nativeConstantSourceNode = nativeContext.createConstantSource();\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n        return nativeConstantSourceNode;\n    };\n};\n//# sourceMappingURL=native-constant-source-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConstantSourceNodeRendererFactory = (connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConstantSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createConstantSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeConstantSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode, trace);\n            return nativeConstantSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=constant-source-node-renderer-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = nativeContext.createConvolver();\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCount', (get) => () => get.call(nativeConvolverNode), (set) => (value) => {\n            if (value > 2) {\n                throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n        });\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        overwriteAccessors(nativeConvolverNode, 'channelCountMode', (get) => () => get.call(nativeConvolverNode), (set) => (value) => {\n            if (value === 'max') {\n                throw createNotSupportedError();\n            }\n            return set.call(nativeConvolverNode, value);\n        });\n        return nativeConvolverNode;\n    };\n};\n//# sourceMappingURL=native-convolver-node-factory.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeConvolverNodes = new WeakMap();\n        const createConvolverNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeConvolverNode = getNativeAudioNode(proxy);\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode, trace);\n            }\n            return nativeConvolverNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n                return createConvolverNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=convolver-node-renderer-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDelayNodeRendererFactory = (connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return (maxDelayTime) => {\n        const renderedNativeDelayNodes = new WeakMap();\n        const createDelayNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeDelayNode = getNativeAudioNode(proxy);\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode, trace);\n            return nativeDelayNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n                return createDelayNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=delay-node-renderer-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDynamicsCompressorNodeRendererFactory = (connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap();\n        const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode, trace);\n            return nativeDynamicsCompressorNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=dynamics-compressor-node-renderer-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createGainNodeRendererFactory = (connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeGainNodes = new WeakMap();\n        const createGainNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeGainNode = getNativeAudioNode(proxy);\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode, trace);\n            return nativeGainNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n                return createGainNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=gain-node-renderer-factory.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n        return new Promise((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n            nativeOfflineAudioContext.oncomplete = (event) => {\n                gainNode.disconnect();\n                resolve(event.renderedBuffer);\n            };\n            gainNode.connect(nativeOfflineAudioContext.destination);\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=render-native-offline-audio-context.js.map","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=test-offline-audio-context-current-time-support.js.map","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz, magResponse, phaseResponse) => {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n//# sourceMappingURL=wrap-iir-filter-node-get-frequency-response-method.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome, Edge & Opera support the new interface already.\n        const createFakeAudioParams = () => {\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n            const createFakeAudioParam = (input, value) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: value\n                });\n                constantSourceNode.connect(channelMergerNode, 0, input);\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get() {\n                        return value;\n                    }\n                });\n                /*\n                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                return createAudioParam({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            };\n            let lastOrientation = [0, 0, -1, 0, 1, 0];\n            let lastPosition = [0, 0, 0];\n            // tslint:disable-next-line:deprecation\n            scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                const orientation = [\n                    inputBuffer.getChannelData(0)[0],\n                    inputBuffer.getChannelData(1)[0],\n                    inputBuffer.getChannelData(2)[0],\n                    inputBuffer.getChannelData(3)[0],\n                    inputBuffer.getChannelData(4)[0],\n                    inputBuffer.getChannelData(5)[0]\n                ];\n                if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                    nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n                    lastOrientation = orientation;\n                }\n                const positon = [\n                    inputBuffer.getChannelData(6)[0],\n                    inputBuffer.getChannelData(7)[0],\n                    inputBuffer.getChannelData(8)[0]\n                ];\n                if (positon.some((value, index) => value !== lastPosition[index])) {\n                    nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n                    lastPosition = positon;\n                }\n            };\n            channelMergerNode.connect(scriptProcessorNode);\n            return {\n                forwardX: createFakeAudioParam(0, 0),\n                forwardY: createFakeAudioParam(1, 0),\n                forwardZ: createFakeAudioParam(2, -1),\n                positionX: createFakeAudioParam(6, 0),\n                positionY: createFakeAudioParam(7, 0),\n                positionZ: createFakeAudioParam(8, 0),\n                upX: createFakeAudioParam(3, 0),\n                upY: createFakeAudioParam(4, 1),\n                upZ: createFakeAudioParam(5, 0)\n            };\n        };\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n        return {\n            get forwardX() {\n                return forwardX;\n            },\n            get forwardY() {\n                return forwardY;\n            },\n            get forwardZ() {\n                return forwardZ;\n            },\n            get positionX() {\n                return positionX;\n            },\n            get positionY() {\n                return positionY;\n            },\n            get positionZ() {\n                return positionZ;\n            },\n            get upX() {\n                return upX;\n            },\n            get upY() {\n                return upY;\n            },\n            get upZ() {\n                return upZ;\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-listener-factory.js.map","import { CONTEXT_STORE } from '../globals';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) => {\n    return class MinimalBaseAudioContext extends eventTargetConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext);\n            this._nativeContext = _nativeContext;\n            CONTEXT_STORE.set(this, _nativeContext);\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n            this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n            this._listener = createAudioListener(this, _nativeContext);\n            this._onstatechange = null;\n        }\n        get currentTime() {\n            return this._nativeContext.currentTime;\n        }\n        get destination() {\n            return this._destination;\n        }\n        get listener() {\n            return this._listener;\n        }\n        get onstatechange() {\n            return this._onstatechange;\n        }\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeContext.onstatechange = wrappedListener;\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange =\n                nativeOnStateChange !== null && nativeOnStateChange === wrappedListener\n                    ? value\n                    : nativeOnStateChange;\n        }\n        get sampleRate() {\n            return this._nativeContext.sampleRate;\n        }\n        get state() {\n            return this._nativeContext.state;\n        }\n    };\n};\n//# sourceMappingURL=minimal-base-audio-context-constructor.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = nativeContext.createOscillator();\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        }\n        else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome, Edge & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n        return nativeOscillatorNode;\n    };\n};\n//# sourceMappingURL=native-oscillator-node-factory.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createOscillatorNodeRendererFactory = (connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeOscillatorNodes = new WeakMap();\n        let periodicWave = null;\n        let start = null;\n        let stop = null;\n        const createOscillatorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeOscillatorNode = getNativeAudioNode(proxy);\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: periodicWave === null ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode, trace);\n            return nativeOscillatorNode;\n        };\n        return {\n            set periodicWave(value) {\n                periodicWave = value;\n            },\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n                return createOscillatorNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=oscillator-node-renderer-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                    (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    }\n                    else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n            isConnected = true;\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-wave-shaper-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n        // Bug #104: Chrome, Edge and Opera will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', (get) => () => get.call(nativeWaveShaperNode), (set) => (value) => {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n                if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                    disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n                }\n                else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                    disconnectNativeAudioBufferSourceNode();\n                    disconnectNativeAudioBufferSourceNode = null;\n                }\n            }\n            return value;\n        });\n        const whenConnected = () => {\n            isConnected = true;\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-wave-shaper-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections) => {\n    return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {\n        const pannerNode = nativeContext.createPanner();\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        };\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            curve: new Float32Array([1, 1]),\n            oversample: 'none'\n        });\n        let lastOrientation = [orientationX, orientationY, orientationZ];\n        let lastPosition = [positionX, positionY, positionZ];\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation = [\n                inputBuffer.getChannelData(0)[0],\n                inputBuffer.getChannelData(1)[0],\n                inputBuffer.getChannelData(2)[0]\n            ];\n            if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n            }\n            const positon = [\n                inputBuffer.getChannelData(3)[0],\n                inputBuffer.getChannelData(4)[0],\n                inputBuffer.getChannelData(5)[0]\n            ];\n            if (positon.some((value, index) => value !== lastPosition[index])) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n            }\n        };\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativePannerNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle() {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle() {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain() {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Safari does not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n                pannerNode.coneOuterGain = value;\n            },\n            get context() {\n                return pannerNode.context;\n            },\n            get distanceModel() {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get maxDistance() {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs() {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX() {\n                return orientationXGainNode.gain;\n            },\n            get orientationY() {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ() {\n                return orientationZGainNode.gain;\n            },\n            get panningModel() {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n            },\n            get positionX() {\n                return positionXGainNode.gain;\n            },\n            get positionY() {\n                return positionYGainNode.gain;\n            },\n            get positionZ() {\n                return positionZGainNode.gain;\n            },\n            get refDistance() {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor() {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n            waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n            waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n            waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n            waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n            waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n            waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n            channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-panner-node-faker-factory.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createPannerNodeRendererFactory = (connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let renderedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode(proxy);\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n            // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            }\n            else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise.all([\n                            proxy.orientationX,\n                            proxy.orientationY,\n                            proxy.orientationZ,\n                            proxy.positionX,\n                            proxy.positionY,\n                            proxy.positionZ\n                        ].map(async (audioParam, index) => {\n                            const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: index === 0 ? 1 : 0\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset, trace);\n                            return nativeConstantSourceNode;\n                        }));\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode, trace);\n                const channelDatas = [];\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n                inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n                    if (orientation.some((value, index) => value !== lastOrientation[index]) ||\n                        positon.some((value, index) => value !== lastPosition[index])) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n                        inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n                return nativeGainNode;\n            }\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n            }\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode, trace);\n            }\n            return nativePannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=panner-node-renderer-factory.js.map","export const createNativePeriodicWaveFactory = (createIndexSizeError) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n        const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n            throw createIndexSizeError();\n        }\n        return nativePeriodicWave;\n    };\n};\n//# sourceMappingURL=native-periodic-wave-factory.js.map","export const sanitizePeriodicWaveOptions = (options) => {\n    const { imag, real } = options;\n    if (imag === undefined) {\n        if (real === undefined) {\n            return { ...options, imag: [0, 0], real: [0, 0] };\n        }\n        return { ...options, imag: Array.from(real, () => 0), real };\n    }\n    if (real === undefined) {\n        return { ...options, imag, real: Array.from(imag, () => 0) };\n    }\n    return { ...options, imag, real };\n};\n//# sourceMappingURL=sanitize-periodic-wave-options.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        const nativeStereoPannerNode = nativeContext.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeStereoPannerNode;\n    };\n};\n//# sourceMappingURL=native-stereo-panner-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' };\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' };\n    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE }));\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve }));\n        return {\n            connectGraph() {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            }\n            else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE }));\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n        return {\n            connectGraph() {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForLeftOutputWaveShaperNode\n                    : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForRightOutputWaveShaperNode\n                    : leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForLeftOutputWaveShaperNode\n                    : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForRightOutputWaveShaperNode\n                    : rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForLeftOutputWaveShaperNode\n                    : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForRightOutputWaveShaperNode\n                    : leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForLeftOutputWaveShaperNode\n                    : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForRightOutputWaveShaperNode\n                    : rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n    };\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n        let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return inputGainNode.context;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan() {\n                return panGainNode.gain;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        let isConnected = false;\n        const whenConnected = () => {\n            connectGraph();\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n            isConnected = false;\n        };\n        return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-stereo-panner-node-faker-factory.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createStereoPannerNodeRendererFactory = (connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeStereoPannerNodes = new WeakMap();\n        const createStereoPannerNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeStereoPannerNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n            }\n            else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n            }\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode, trace);\n            }\n            return nativeStereoPannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=stereo-panner-node-renderer-factory.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeWaveShaperNodes = new WeakMap();\n        const createWaveShaperNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeWaveShaperNode = getNativeAudioNode(proxy);\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0], trace);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode, trace);\n            }\n            return nativeWaveShaperNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=wave-shaper-node-renderer-factory.js.map","export const createIsSecureContext = (window) => window !== null && window.isSecureContext;\n//# sourceMappingURL=is-secure-context.js.map","export const createExposeCurrentFrameAndCurrentTime = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get() {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get() {\n                    return currentTime;\n                }\n            }\n        });\n        try {\n            return fn();\n        }\n        finally {\n            if (window !== null) {\n                delete window.currentFrame;\n                delete window.currentTime;\n            }\n        }\n    };\n};\n//# sourceMappingURL=expose-current-frame-and-current-time.js.map","export const createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor) => {\n    return (nativeContext) => {\n        let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n        if (backupOfflineAudioContext !== undefined) {\n            return backupOfflineAudioContext;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 8000);\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n        return backupOfflineAudioContext;\n    };\n};\n//# sourceMappingURL=get-or-create-backup-offline-audio-context.js.map","export const createNativeAudioWorkletNodeConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n//# sourceMappingURL=native-audio-worklet-node-constructor.js.map","export const createEvaluateSource = (window) => {\n    return (source) => new Promise((resolve, reject) => {\n        if (window === null) {\n            // Bug #182 Chrome, Edge and Opera do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n            return;\n        }\n        const head = window.document.head;\n        if (head === null) {\n            // Bug #182 Chrome, Edge and Opera do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n        }\n        else {\n            const script = window.document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            const blob = new Blob([source], { type: 'application/javascript' });\n            const url = URL.createObjectURL(blob);\n            const originalOnErrorHandler = window.onerror;\n            const removeErrorEventListenerAndRevokeUrl = () => {\n                window.onerror = originalOnErrorHandler;\n                URL.revokeObjectURL(url);\n            };\n            window.onerror = (message, src, lineno, colno, error) => {\n                // @todo Edge thinks the source is the one of the html document.\n                if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                    removeErrorEventListenerAndRevokeUrl();\n                    reject(error);\n                    return false;\n                }\n                if (originalOnErrorHandler !== null) {\n                    return originalOnErrorHandler(message, src, lineno, colno, error);\n                }\n            };\n            script.onerror = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                // Bug #182 Chrome, Edge and Opera do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n            };\n            script.onload = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n        }\n    });\n};\n//# sourceMappingURL=evaluate-source.js.map","export const createAbortError = () => new DOMException('', 'AbortError');\n//# sourceMappingURL=abort-error.js.map","// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\nexport const createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'], {\n            type: 'application/javascript; charset=utf-8'\n        });\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 8000);\n        const url = URL.createObjectURL(blob);\n        let isEmittingMessageEvents = false;\n        let isEmittingProcessorErrorEvents = false;\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n            audioWorkletNode.port.onmessage = () => (isEmittingMessageEvents = true);\n            audioWorkletNode.onprocessorerror = () => (isEmittingProcessorErrorEvents = true);\n            oscillator.connect(audioWorkletNode);\n            await offlineAudioContext.startRendering();\n        }\n        catch {\n            // Ignore errors.\n        }\n        finally {\n            URL.revokeObjectURL(url);\n        }\n        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n    };\n};\n//# sourceMappingURL=test-audio-worklet-processor-post-message-support.js.map","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=is-native-context.js.map","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome, Edge and Opera do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        }\n        catch {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                audioBufferStore.add(audioBuffer);\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    detachArrayBuffer(audioData);\n                }\n                catch {\n                    // Ignore errors.\n                }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    audioBufferStore.add(audioBuffer);\n                    complete();\n                    resolve(audioBuffer);\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=decode-audio-data.js.map","export const detachArrayBuffer = (arrayBuffer) => {\n    const { port1 } = new MessageChannel();\n    port1.postMessage(arrayBuffer, [arrayBuffer]);\n};\n//# sourceMappingURL=detach-array-buffer.js.map","export const createDataCloneError = () => new DOMException('', 'DataCloneError');\n//# sourceMappingURL=data-clone-error.js.map","export const createEncodingError = () => new DOMException('', 'EncodingError');\n//# sourceMappingURL=encoding-error.js.map","export const createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaElementAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n            super(context, true, nativeMediaElementAudioSourceNode, null);\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n        get mediaElement() {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n//# sourceMappingURL=media-element-audio-source-node-constructor.js.map","export const createNativeMediaElementAudioSourceNode = (nativeAudioContext, options) => {\n    return nativeAudioContext.createMediaElementSource(options.mediaElement);\n};\n//# sourceMappingURL=native-media-element-audio-source-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeMediaStreamAudioDestinationNode = (nativeAudioContext, options) => {\n    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n    // Bug #174: Safari does expose a wrong numberOfOutputs.\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n    }\n    return nativeMediaStreamAudioDestinationNode;\n};\n//# sourceMappingURL=native-media-stream-audio-destination-node.js.map","export const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            super(context, true, nativeMediaStreamAudioSourceNode, null);\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n        get mediaStream() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n//# sourceMappingURL=media-stream-audio-source-node-constructor.js.map","export const createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    /*\n     * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n     * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n     */\n    audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0));\n    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n    /*\n     * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n     * to be overwritten as it would otherwise expose the reconstructed version.\n     */\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n    return nativeMediaStreamAudioSourceNode;\n};\n//# sourceMappingURL=native-media-stream-audio-source-node.js.map","export const createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) => {\n    return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, null);\n        }\n    };\n};\n//# sourceMappingURL=media-stream-track-audio-source-node-constructor.js.map","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, isNativeOfflineAudioContext) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n        const mediaStream = new MediaStream([mediaStreamTrack]);\n        const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n            throw createInvalidStateError();\n        }\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n            throw new TypeError();\n        }\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n//# sourceMappingURL=native-media-stream-track-audio-source-node-factory.js.map","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n    return class AudioContext extends baseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome, Edge and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, 2);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                        ? 512 / sampleRate\n                        : latencyHint === 'interactive' || latencyHint === undefined\n                            ? 256 / sampleRate\n                            : latencyHint === 'playback'\n                                ? 1024 / sampleRate\n                                : /*\n                                   * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                                   * ScriptProcessorNode.\n                                   */\n                                    (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n                this._nativeGainNode.gain.value = 1e-37;\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            }\n            else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n            this._state = null;\n            /*\n             * Bug #34: Chrome, Edge and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n             * changes to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n                deactivateAudioGraph(this);\n            });\n        }\n        createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n        createMediaStreamDestination() {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n        createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n        createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=audio-context-constructor.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n//# sourceMappingURL=connect-multiple-outputs.js.map","export const createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=delete-unrendered-audio-worklet-node.js.map","export const createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore, getValueForKey) => {\n    return (nativeAudioWorkletNode) => getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=get-active-audio-worklet-node-inputs.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: options.parameterData[name] !== undefined\n                        ? options.parameterData[name]\n                        : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = typeof value === 'function' ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = typeof args[1] === 'function'\n                        ? args[1]\n                        : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = typeof value === 'function' ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters = processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n        const activeInputIndexes = new Map();\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n                                return input;\n                            }\n                            const count = activeInputIndexes.get(index);\n                            if (count === undefined) {\n                                return [];\n                            }\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                }\n                                else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n                            colno: error.colno,\n                            filename: error.filename,\n                            lineno: error.lineno,\n                            message: error.message\n                        }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        else {\n                            disconnectFakeGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-faker-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n    return audioWorkletProcessorPromise;\n};\n//# sourceMappingURL=create-audio-worklet-processor.js.map","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeContext, name, options);\n                const patchedEventListeners = new Map();\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = typeof value === 'function' ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = typeof args[1] === 'function'\n                                ? args[1]\n                                : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        // Bug #178: Chrome, Edge and Opera do fire an event of type error.\n                                        if (event.type === 'error') {\n                                            Object.defineProperties(event, {\n                                                type: { value: 'processorerror' }\n                                            });\n                                            unpatchedEventListener(event);\n                                        }\n                                        else {\n                                            unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                                        }\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        // Bug #178: Chrome, Edge and Opera do fire an event of type error.\n                        addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                        return addEventListener.call(nativeAudioWorkletNode, ...args);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        // Bug #178: Chrome, Edge and Opera do fire an event of type error.\n                        removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                /*\n                 * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n                 * has an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n                    nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome, Edge & Opera throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err;\n            }\n        }\n        // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-factory.js.map","export const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    const { port1 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n    }\n};\n//# sourceMappingURL=test-clonability-of-audio-worklet-node-options.js.map","export const createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore) => {\n    return (nativeContext) => {\n        return backupOfflineAudioContextStore.get(nativeContext);\n    };\n};\n//# sourceMappingURL=get-backup-offline-audio-context.js.map","export const createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore) => {\n    return (nativeAudioWorkletNode, activeInputs) => {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n    };\n};\n//# sourceMappingURL=set-active-audio-worklet-node-inputs.js.map","export const sanitizeAudioWorkletNodeOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: options.outputChannelCount !== undefined\n            ? options.outputChannelCount\n            : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                    [options.channelCount]\n                : Array.from({ length: options.numberOfOutputs }, () => 1)\n    };\n};\n//# sourceMappingURL=sanitize-audio-worklet-node-options.js.map","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome Edge, and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, 2);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                        ? 512 / sampleRate\n                        : latencyHint === 'interactive' || latencyHint === undefined\n                            ? 256 / sampleRate\n                            : latencyHint === 'playback'\n                                ? 1024 / sampleRate\n                                : /*\n                                   * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                                   * ScriptProcessorNode.\n                                   */\n                                    (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n                this._nativeGainNode.gain.value = 1e-37;\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            }\n            else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n            this._state = null;\n            /*\n             * Bug #34: Chrome, Edge and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n             * changes to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n                deactivateAudioGraph(this);\n            });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=minimal-audio-context-constructor.js.map","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        }\n        catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            if (err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n            throw err;\n        }\n    };\n};\n//# sourceMappingURL=create-native-offline-audio-context.js.map","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    const trace = [];\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext, trace)\n        /*\n         * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n         * destination.\n         */\n        .then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext, trace))))\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=start-rendering.js.map","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;"],"sourceRoot":""}